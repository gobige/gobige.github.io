---
layout: post
title: 'redis'
subtitle: 'redis'
date: 2019-11-1
categories: 中间件
author: yates
cover: 'www.baidu.com'
tags: 中间件
---

## **前言**

### **数据结构**

Redis所有数据结构都是字符串作为名称，然后通过key获取**不同的value结构**数据

**字符串**

- Rdis字符串是**动态字符串**，内部结构类似于Java ArrayList，冗余分配空间，**最大长度512M**
- 如果value时整数，可进行增减操作，最大值为signed long最大值

**列表**

- 数据结构类似于Java的LinkedList，插入，删除很快，索引查询定位慢
	- quicklist：元素稍等时候使用一块连续内存存储ziplist，压缩列表。数据量多时变为quicklist，多个ziplist使用双向指针串起来使用。既满足了快速插入删除，又不会太大空间冗余
- 列表弹最后一个元素，数据结构自动被删除

**hash**

- 数据结构类似于Java的HashMap，但是rehash采用**渐进式rehash**（保留新旧两个hash结构，查询同时查询两个，逐渐迁移旧内容到新结构）策略，避免了堵塞服务
- 存储消耗高于单个字符串

**set**

- 数据结构类似于Java的HashSet,字典中value值为NULL
- 集合移除最后一个元素，数据结构自动被删除

**zset**

- 数据结构类似于Java的SortedSet和HashMap,内部实现**跳表**

list/set/hash/zset都是**create if not exists，drop if no elements**

### **分布式锁**

- 2.8以前，setnx和expire指令是分开的，会造成死锁的问题，2.8以后**合并为原子指令**
- **锁超时**导致锁释放，另外线程获取锁，被之前执行完任务线程解锁。导致**锁失效**问题。通过**value设值为随机数，释放锁进行对比**
- 锁冲突：1.抛异常；2.sleep再次请求；3.入延迟队列，过会再试

### **异步消息队列**

队列为null导致空转

- 使用sleep解决
- 使用blpop/brpop代替lpop/rpop，阻塞读在没有数据，自动进入休眠直到数据到来
 
### **空闲连接自动断开**

Redis服务器会自动断开长时间无请求客户端连接，客户端再次请求会抛异常，**注意捕获**

### **延迟队列**

使用zset实现延迟队列，多线程并发获取任务，loop方法可多线程同时调用，，zrem方法返回决定唯一获取到任务属主

### **位图**

本质是**byte数组**，用于存储类似于bool型数据，数组自动扩展，某偏移位置超出数组长度，自动将位数组进行零扩充，适用**签到**等场景。

```java
// 将 1 位设置为 1
setbit s 1 1
// 获取 2 位 的 值
getbit s 2

// 统计为1的位数
bitcount s
// 统计范围start end 为1的位数（start end是8倍数）
bitcount s 0 1
// 从哪一位开始第一个是1的位
bitpos w 1
// 对指定位片段进行读写，但是最多只能处理 64 个连续的位
bitfield w get u4 0 从第一个位开始取 4 个位，结果是无符号数 (u)
```

### **HyperLogLog**

提供不精确的去重计数方案,标准误差是 0.81%，占用12k存储空间

常用于统计场景，但不是哪种特别多数据例如每个用户相关统计

```java
// 增加计数
 pfadd codehole user1
// 获取计数
 pfcount codehole
// 多个pf计数值进行合并
 pfmerge codehole1 codehole2
```

### **布隆过滤器**

4.0以插件形式出现
```java
 docker pull redislabs/rebloom # 拉取镜像
> docker run -p6379:6379 redislabs/rebloom # 运行容器
> redis-cli #
```

```java
// 添加元素
bf.add codehole user1
// 是否存在
bf.exists codehole user1
// 添加多个元素
bf.madd codehole user4 user5 user6
// 是否存在多个元素
 bf.mexists codehole user4 user5 user6 user7
 
// 自定义布隆过滤器
bf.reserve（key, error_rate, initial_size）//  误判率  预计元素数量
```

### **漏斗限流**

Redis-Cell todo

### **地理位置距离排序**

**GeoHash 算法**

。GeoHash 算法将二维的经纬度数据映射到一维的整数，个一维的线上获取附近的点。通过无限两刀切分割二维平面为二进制 。

```java
// 添加地理位置
geoadd company 116.48105 39.996794 addressA
// 计算两元素间距离
geodist company addressA addressB km
// 获取地址坐标
geopos company addressA
// 获取元素经纬度hash字符串
geohash company addressA
// 查询指定元素附近其他元素
georadiusbymember company addressA 20 km count 3 asc/desc
// 
georadiusbymember company addressA 20 km withcoord withdist withhash count 3 asc

// 根据坐标值查询元素
georadius company 116.514202 39.905409 20 km withdist count 3 asc
```

**如果数据量过大，还需对数据拆分，国家，省，市，降低单个zset集合大小**


### **模糊匹配**

```java
// 没有offset，limit一次获取数量不可预计；会造成redis其他指令阻塞
keys yang*

// 通过游标分布进行不会阻塞线程；提供limit参数；但需客户端进行去重
scan 1996 match key99* count 1000//cursor 正则 limit

1) "12594"
2) 1) "key9939"
 2) "key9941"
 3) "key9967"
 4) "key9938"
 5)
 
```

Redis的key存储在一个类似于HashMap的字典中，scan返回结果游标为数组中索引slot，limit表示遍历slot数，所以返回结果元素有多有少

scan遍历使用高位加法遍历，避免字典扩缩容导致遍历重复和遗漏

**大key会造成集群迁移 redis卡顿，可以通过scan查看key的len大小，类型**



![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/redis/1.png)
![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/redis/2.jpg)
![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/redis/3.jpg)
![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/redis/4.jpg)