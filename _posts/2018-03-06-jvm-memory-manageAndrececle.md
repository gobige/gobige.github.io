---
layout: post
title: 'jvm内存管理及算法'
subtitle: 'jvm内存数据管理及GC算法的'
date: 2017-03-06
categories: jvm
author: yates
cover: 'http://cctv.com'
tags: jvm
---


### java内存管理之数据区域划分

![请输入图片地址](http://muyibeyond.cn/img/2018-03-19-jvm/1.png)

**运行时数据区域**
java虚拟机在程序运行中会将内存划分为不同的数据区域，这些区域有着不同的用处和不同的生存时间

- 程序计数器：每条**线程独立存储且私有**的区域，用于记录程序执行中所处于虚拟机**字节码指令地址**，如果执行的是本地native方法，这个值为空，这个区域**不会发生outOfMemoryError**

- Java虚拟机栈：线程私有用于存储**java方法**执行时的**局部变量表，操作数栈，动态链接，方法出口等信息**，在这个区域栈深度如果大于jvm设置的栈深度，会抛出StackOverflowError，如果通过动态扩展申请不到足够内存，会发生outOfMemoryError

- 本地方法栈：native方法执行会用到的数据区域，会发生StackOverflowError和outOfMemoryError

- Java堆：jvm管理最大的内存区域，GC发生区域，线程共享的区域，存放对象实例和数组，会发生OutOfMemoryError

- 方法区：线程共享的区域，GC发生区域，存放jvm加载的类信息，常量（运行时常量池），静态变量，即时编译代码，会发生OutOfMemoryError

- 直接内存：NIO存放缓存，受本机内存影响会发生OutOfMemoryError

### java对象访问定位方式
java通过在栈上的reference数据（执行对象的指针）来操作堆上的具体对象

- 句柄：java堆开辟一块区域作为句柄池，句柄存储对象实例数据和类型数据各种具体地址，此时栈中reference存储的是句柄地址，GC对象物理地址改变时，这种方式只需修改句柄的中对象地址
![请输入图片地址](http://muyibeyond.cn/img/2018-03-19-jvm/2.png)
- 直接指针：栈中reference存储的是对象地址，这种方式节省了一次指针定位时间开销
![请输入图片地址](http://muyibeyond.cn/img/2018-03-19-jvm/3.png)

### java对象存活判断
- 引用计数器算法：给对象加一个引用计数器，每当一个地方引用，计数器加1，当失效时，计数器-1，当计数器为0时进行GC，优点：简单，高效。缺点：无法判断对象相互问题
-  可达性分析：从一个GC Roots对象开始，向下搜索所有节点，当一个对象到GCroots对象没有任何引用链相连时，判定为可回收对象。可作为GC Roots的对象：1：虚拟机栈（栈帧中的本地变量表）中引用的对象。2：方法区中类静态属性引用的对象。3：方法区中常量引用的对象。4：本地方法栈中Native方法引用的对象

### java引用类型
- 强引用：程序代码普遍存在，GC永远不会发生
- 软引用：还有用但非必须对象，发生outOFMemery前，把这些对象放入进行二次回收，JAVA中使用SoftReference类进行软引用
- 弱引用：关联对象只会存活到下一次GC前，无关内存是否够用，Java中使用WeakReference类实现
- 虚引用：唯一目的使对象被回收时收到一个系统通知，PhantomReference类实现

java在对象回收过程中会进行**两次标记**，对象失去链接-->标记-->是否**拯救**自己（finalsize or not）对象重写建立引用-->没有建立新引用的对象进行二次标记 --> GC回收

回收方法区-回收类-1该类所有的实例都已经被回收 2加载该类的classLocader被回收3该类class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。-Xnoclassgc参数进行控制，大量使用反射，动态代理的框架，地方都应该配置该参数

### jvm内存回收

**方法区回收** 
方法区，HotSpot也叫做永久代，通常这个区域回收的性价比比较低，这个区域回收的内容主要是**废弃常量**和**无用的类**
方法区判断可以回收的方法：
1. 该类所有的实例都已经被回收 
2. 加载该类的classLocader被回收
3. 该类class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。

**垃圾回收算法**
- 标记-清除算法：首先**标记出所需清除**的回收的对象，标记完成后统一**回收所有被标记**的对象。缺点：标记，清除过程效率都不高 2 产生空间碎片
- 复制算法--实现：将可用内存**二分为一**，每次使用其中一块，**复制**存活对象到另一块，**清除**所有第一块的数据。缺点：内存缩小原来一半。现代商业jvm都采用这种方式回收新生代
- 标记-整理--实现：**标记存活**数据，然后将其向一边移动，**清理掉边界外**数据。大多数jvm老年代采用这种方式
- 分代收集算法--根据对象**存活周期**分配到不同内存区域，按照不同数据区域进行**不同的算法**实现

**枚举根节点**
可达性分析应建立在能确保**一致性的快照**中进行，确保对象引用关系不会在变化，通常会采用Stop The world操作，停止所有执行线程。而GC停顿时长是敏感的，在HotSpot中使用**OopMap数据**结构在类加载时就计算对象内的所有类型数据的偏移量，记录栈和寄存器引用。从而实现准确，快速的**GS Roots节点的获取**。

**安全点**
当JVM进行GC时，要保证所有执行执行线程都处于一个安全的位置，这个位置叫做安全点，而为了保证所有执行线程处于安全点有两种方式 1 **抢断式中断** jvmGC时停止所有执行线程，如果发现有执行线程不在安全点上，恢复其线程，到达安全点。2 **主动式中断** 设置一个标志，执行线程主动轮询这个标志，如果标志位置和安全点位置重合，则挂起线程

**安全区域**
安全点的设置会导致不太长时间就会上面一系列操作，效率会很低。安全区域指一段代码片段之中，**引用关系不会发生变化**，这个区域任何时候GC都是安全的。当线程**进入**安全区域是**标记**自己进入，当jvmGC时，不用关心这个线程；线程当**离开**安全区域时，检查**GC是否完成**，未完成则等待释放信号


### 内存分配，回收策略

**优先分配到Eden区**
大多数情况对象**优先分配到Eden**区，当**Eden内存不够**时，jvm进行**minor GC**（发生在新生代的垃圾回收动作，很频繁）
- 还是不够就用老年代进行担保

**大对象直接进入老年代**
当创建对象时，需要大量连续内存空间的对象，比如大字符串或大数组

**长期存活对象直接进入老年代**
jvm会采用分代收集思想管理内存，jvm为每个创建的对象设定一个Age计数器。如果对象在eden出生，在经过第一次GC存活，并且进入survivor区，那么age加1，在survivor区以后每一次minor GC后存活，age加1；当达到一定age进入老年代

**动态对象年龄判断**
当survivor中**相同年龄**所有对象大小**总和大于**Survivor空间**一半**，大于该年龄的对象进入老年代

**空间分配担保**
Minor GC前jvm会判断老年代**最大可用连续空间**是否大于**新生代所有对象总空间**，如果条件成立，那么minor GC时安全的；如果不成立，查看允许担保配置HandlePromotionFailure值**是否允许担保失败**，如果没有配置则进行FullGC(发生在老年代的GC，会比minor GC 慢10倍以上)；如果有配置检查**老年代最大可用连续空间**是否大于**历次晋升老年代对象平均大小**，如果大于则进行minor GC，否则full GC
