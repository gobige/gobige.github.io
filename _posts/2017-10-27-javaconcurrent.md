---
layout: post
title: 'java并发'
subtitle: 'java并发的一些知识'
date: 2017-10-27
categories: mysql
author: yates
cover: 'http://cctv.com'
tags: mysql
---

### 一些概念

**同步，异步**
同步方法在被调用后，后面的代码只有在同步方法返回后才能执行；而异步方法不用等待返回，后面的代码就可以执行

**并行，并发**
并发：多个任务在同一个cpu核心中交替进行
并行：多个任务在多个cpu核心中一起进行

**线程优先级**
线程执行需要获得**cpu时间片**资源，线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。在java中通过整形变量1~10设置，越大优先级越高（有些操作系统会忽略线程优先级设定）

**守护线程**
守护一些系统服务的线程

**线程安全**
指的是一个任务在多线程下执行的结果和在单线程下得到的结果是始终是一样的

**新建一个线程的方式**
1. 继承Thread类，重写run方法（不建议，java不支持多继承）
2. 实现runable接口
3. 实现callable接口


**线程状态转换**
new：初始状态，线程被构建，还没调用start（）方法
runnable：运行状态，**就绪**和**运行**统称运行中
blocked：阻塞状态，线程获取资源受阻
waiting：等待状态，线程进入等待状态，需要其他线程通知
time_waiting；超时等待，在waiting指定时间后自行返回
terminated：终止状态，当前线程已经执行完毕

**java中线程状态操作**

- interrupted：中断操作，表示一个运行中的线程是否被其他线程进行中断操作。在java中其他线程调用被中断线程的interrupt()方法进行中断操作（也可调用Thread的静态方法interrupted()对当前线程进行中断操作，同时**中断标志位**会被清除）
- join：线程A等待线程B线程终止后线程A才继续执行（或者设置等待超时后继续执行）
- sleep：让当前线程按照指定时间进行休眠，**让出cpu资源**，休眠期间**不会释放锁**，休眠完成后进入**就绪状态**
- yield：让当前线程**让出cpu资源**，进入就绪状态，继续和当前线程**相同优先级的线程**竞争cpu时间片



### 线程之间交互
线程通信方式主要有共享内存和线程通信方式两种方式，java采用的是共享内存的方式

**java的内存模型（JMM）**

java运行时数据区域如下

- 程序计数器-当前线程执行的字节码行号指示器
- Java虚拟机栈-java方法执行内存模型，包含局部变量表，操作数栈，动态链接，方法出口
- 本地方法栈：native方法用到的栈
- Java堆-**线程共享**的一块儿区域，存放java对象
- 方法区-加载类信息，常量，静态变量，即使编译代码
- 运行时常量池（方法区一部分）-编译期生成的各种字面量，符号
- 直接内存-NIO存放缓存

线程共享变量获取

![此处输入图片的描述](http://www.muyibeyond.cn/img/20172017-10-27-javaconcurrent/1.png)

CPU的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存，通常是三级缓存，L1,L2,L3;L1是最接近CPU的，容量最小，速度最快，每个核上有两个L1Cache，一个存数据 L1d Cache，一个存指令 L1i Cache)。L2 Cache大一些，速度要慢一些，一般情况下每个核上都有一个独立的L2Cache；L3Cache是三级缓存中最大的一级，同时也是最慢的一级，在同一个CPU插槽之间的核共享一个L3Cache

线程A和线程B要完成通信，如下

1. 线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中
2. 线程B从主存中读取最新的共享变量

如果在线程A还没有把数据刷入主内存时，线程B拿到主内存数据，并且使用，得到的数据就是脏数据，就发生了常说的线程安全问题

**重排序**
在不改变程序执行结果的前提下，cpu和编译器会对代码编译后的指令和代码进行重排序，从而提高执行效率

代码执行过程
![此处输入图片的描述](http://www.muyibeyond.cn/img/20172017-10-27-javaconcurrent/1.png)

**happens-before规则**
指的是两个操作之间的**执行顺序**，一个操作位于另一个操作之前发生，这两个操作可以同一个线程，也可以不是同一个线程。
JMM承诺保证happend-before的关系，不仅为程序员提供了足够强的**内存可见性**，而且对编译器和处理器的限制尽可能放松（允许不会改变程序结果的**重排序**）


- 定义 
    1. 如果一个操作happened-before另一个操作，那么第一个操作的执行结果对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
    2. 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）

- 具体规则
    1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
    2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
    3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
    4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
    5. start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
    6. join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回
    7. 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
    8. 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。