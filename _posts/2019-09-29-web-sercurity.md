---
layout: post
title: '程序性能优化'
subtitle: '程序性能优化'
date: 2019-09-29
categories: 性能
author: yates
cover: 'www.baidu.com'
tags: 性能
---

**性能指标**

- 系统负载：代表**单位时间**内正在**运行或等待**的**进程**和**线程**数。
- 计算机资源分配使用率：
    - **CPU占用率**：代表**单位时间**内**线程或进**程实时**占用CPU**的百分比
    - I/O：
    - 内存使用率：已经使用内存/总内存
- 响应时间：一个请求的响应时间，分为数据库，服务端，网络，客户端响应时间
- 吞吐量：每秒**事务**处理量（TPS） 
    - 磁盘吞吐量：
        - IOPS：每秒输入输出量（读写次数），**单位时间**系统处理**I/O请求**数量。
        - 数据吞吐量：**单位时间**成功**传输数据量**。
    - 网络吞吐量：指网络传输时没有帧丢失情况下，**设备**能够接受**最大数据速率**。

**测试方法**

- **微基准**性能测试：可以精准定位到某个**模块**或某个**方法**性能问题，适用于功能模块或一个方法**不同实现方式**性能对比。
- **宏碁准**性能测试：模拟线上**正式环境**，并且确定某个测试接口是否有**其它业务接口平行运行**，造成干扰。通过**吞吐量，响应时间**等观察各项指标，衡量系统是否达标。

**需要考虑的问题**

- **热身**问题：热身时间过长会导致第一次访问速度过慢，可以考虑先优化，再测试
- 测试**结果不稳定**：通过多次测试，取平**均值**
- 多**JVM影响**：如果多个java应用部署多台tomcat，就会有多个JVM，每一个JVM都拥有整个系统资源使用权。

通过**测试结果**，观察**性能指标**，首先从操作系统，查看**系统是否异常**，再通过日志查找**异常日志**，分析日志，找到原因。也可通过**JVM内存分配和垃圾回收情况**查看是否异常。

**调优策略**

- 优化代码
- 优化设计
- 优化算法
- 时间换空间
- 空间换时间
- 参数调优

**兜底策略**

- 限流
- 智能化横向扩容
- 提前扩容

## Java String字符串优化
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/performance/1.png)

**java6**版本使用**offset和count**，可**高效共享**数组，节省内存，但可能导致内存泄漏
**java7/8**版本去除offset和count，同时**substring**方法**不在共享char[]**，避免了内存泄漏
**java9**char字段改为**byte字段**，通过coder识别该字符串是否只有**单字节编码**内字符

**string为什么final修辞**
不仅string类被final修辞，变量char数组也被final修辞，好处

1. 保证String对象**安全性**。
2. 保证**hash**属性值**不会频繁**变更，**唯一**，类似HashMap能够实现key-value缓存
3. 实现**字符串常量池**

大字符串拼接时，jvm编译器会**默认使用stringbuder**进行拼接节省内存。
**字符串常量**中，默认会将对象放入**常量池**；而**字符串变量**，对象在**堆**内存中，同时常量池也会创建字符串对象，引用赋值到堆内存对象；
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/performance/2.png)

字符串分割方法**split使用正则表达式**，而正则表达式性能非常不稳定，最好使用**string.indexOf**方法代替

正则表达式由正则符号写出的公式，程序对公式进行语法分析，建立语法分析树，再根据分析树结合**正则表达式引擎**生成执行程序（状态机），用于字符匹配。目前引擎有两种：**DFA自动机和NFA自动机**。前者**效率**高于后者，后者支持**更多功能**。NFA实现比较复杂正则表达式，带来的是匹配过程可能会引起大量**回溯**。长时间占用CPU。回溯由于正则表达式使用**贪婪模式**造成的

- **贪婪**模式：在数量匹配中，若单独使用**+，？，*或{min,max}**等量词，正则表达式匹配尽可能多内容
- **懒惰**模式：尽可能少重复匹配字符，使用**？**开启
- **独占**模式：和贪婪模式一样最大限度匹配内容，但匹配失败会结束匹配，不会回溯，使用**+**开启

1. 少用贪婪，多用独占 
2. 减少分支选择，
3. 减少捕获嵌套

**常量池**的实现是类似于一个**HashTable**的实现方式，HashTable 存储的**数据越大**，遍历的时间**复杂度增加**

程序代码通过链接得到可执行文件，当不同程序链接相同的功能代码的时候时，如果每个都再装载一遍，就会再占用一遍内存。

## **静态链接**
**合并代码段就是静态链接**

## **动态链接**
链接过程中，我们链接的不是硬盘的目标文件代码，而是加载到内存中的**共享库**。他会被多个程序指令调用到，Windows下，是dll文件，
linux下，是so文件。
共享代码的基础，这些机器码必须是**地址无关**（无论加载到内存任何地方，都能正常秩序）的。（重定位表的代码，是地址相关的。）虽然共享库用的同一段物理地址，但不同程序，虚拟内存是不同的。

**怎么地址无关**
因为**共享库**放在一段**连续虚拟地址**中，无论装载到哪一段地址，不同指令相对地址都是不变。所以**动态代码内部的变量和函数**调用使用**相对地址**就能解决

**PLT**
在编译过程中，我们指定一个**-fPIC**参数。用来指定这是一个地址无关的代码

在动态链接对应的共享库，每个应用在data section里，保存了一张**全局偏移表（GOT）**。**虽然共享库物理内存时共享的，但是数据部分各个动态链接它的应用程序里各加载一份**，需要引用共享库外部地址指令时，查询GOT（加载共享库时写入），找到当前应用程序虚拟内存对应共享库位置。

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/computer-system-Perspective/38.png)
