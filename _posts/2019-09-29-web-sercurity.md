---
layout: post
title: 'WEB安全实践'
subtitle: 'WEB安全实践'
date: 2019-09-29
categories: 安全
author: yates
cover: 'www.baidu.com'
tags: 安全
---

## **安全的基本原则**

CIA三元组：

- 机密性：确保数据只被授权的主体访问，不被未授权主体访问
- 完整性：确保数据只被授权的主体进行修改
- 可用性：确保数据可被授权的主体访问

## **安全解决方案 黄金法则**

**认证：身份识别与认证**

不光你以什么形式进行登入，最终都落地称为唯一的身份id；后续操作，身份id始终跟随会话，记录在日志中。这也是后续授权，审计，问责的基础

认证强度由弱到强：

- 密保，密码问题
- 门禁，安全令牌
- 生物特征，指纹，人脸，虹膜

**授权**

原始和最安全的授权机制，一定是每次操作都经过管理员审批和确认；通常我们定义自动化授权机制信息快速响应，如自主访问控制，强制访问控制

**审计与问责**

授权下完成操作，安全需检查一下做了什么，这叫审计；当发现你做了某些异常操作时，安全提供你的异常操作证据，这个是问责；
通过日志还原用户操作历史，从而判断是否出现违规操作

**web应用程序防御机制核心因素**

- 处理用户访问应用程序的数据和功能，防止用户获得未授权访问
	- 身份验证
	- 会话管理
	- 访问控制
- 处理用对应用程序功能的输入，防止错误输入造成不良行为
	- 输入多样性
	- 输入处理方法
- 防范攻击者，确保应用程序在称为直接攻击目标时能够正常运转，并采用适当防御与攻击挫败攻击者
- 管理应用程序本身，帮助管理员监控其行为，配置其功能

## 加密与解密

[加密与解密](http://muyibeyond.cn/2019/03/09/encode-decode.html)


## 单点登陆身份认证

**CAS**

流程

1. 用户范文应用
2. 应用将用户重定向到认证中心
3. 用户在认证中心进行认证
4. 认证中心返回认证凭据和信息到用户
5. 用户将凭据发送到应用
6. 应用向认证中心验证有效性
7. 完成认证

**JWT**

在客户端保存凭证信息，每次登陆请求带上该凭证，作为登陆状态依据

**OAuth**

通过OAuth，用户完成认证中心认证后，为了维持应用内登陆状态，应用颁发自己登陆凭证。类似于QQ等三方登陆

**OpenID**

和OAuth一样，但是不提供授权，只获得的相关信息，例如：其他应用微信支付



## 访问控制

**访问控制模型**

一个**主体**请求一个**客体**，这个**请求**授权由访问控制来完成

**访问控制机制**

- DAC:让客体所有者定义访问控制规则。具有很高灵活性，维护成本低。实质将安全交到用户手中。 
- role-BAC：将主体划分不同角色，然后对角色权限进行定义。防止权限被滥用，实现最小特权原则。
- rule-BAC：指定某种规则，将主体，请求和客体信息结合起来进行判定；针对请求本身制定访问策略
- MAC：基于安全级别标签的访问策略。机密性不能低读，高写；完整性不能高读，低些。


## 威胁评估

安全方案落地过程中，首先考虑的明确威胁

- 识别数据：当发生数据CIA受到影响时，会造成多大损失，
- 识别攻击：明确什么样的数据被攻击
- 识别漏洞：根据应用识别可能的漏洞

**一切用户输入皆不可信！**

## **弱口令**

**防护策略**：
口令设置做限制，长度，字符组合，大小写，数字，连续字母，数字，和用户名相同连续字符，定期更新

## **未加密登录请求**

用户密码未做加密进行网络传输，存储

## **文件上传漏洞**

严格限制用户上传的文件后缀以及文件类型，限制相关目录执行权限

## **sql注入**

通过表单中填入sql语句导致，越权获取到数据库记录

**防护策略**：

- 表单验证，参数验证，过滤
- mybatis使用#占位符

## **XSS**

攻击者通过在链接中插入恶意代码，就能够盗取用户信息。攻击者通常会用十六进制（或其他编码方式）将链接编码，以免用户怀疑合法性。网站在接收到请求后产成一个恶意代码的页面。

例如：许多留言本和论坛程序允许用户发表包含HTML和javascript的帖子。假设用户甲发表了一篇包含恶意脚本的帖子，那么用户乙在浏览这篇帖子时，恶意脚本就会执行，盗取用户乙的session信息

**防护策略**：

- 验证所有输入数据，有效检测攻击；
- 对所有输出数据进行适当的编码，以防止任何已成功注入的脚本在浏览器端运行
- 对部分浏览器识别关键词进行转换
- 通过白名单过滤输入，通过黑名单拒绝输入
- CSP，因为通常输入受到长度限制。通过在HTTP HEADER头返回定义白名单资源域名。限制外域资源访问，

## **CSRF**

![](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的

**流程**
 
- 受害者登录a.com，并保留了登录凭证（Cookie）。
- 攻击者引诱受害者访问了b.com。
- b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

**特点**

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击利用受害者在被攻击网站的**登录凭证**，**冒充**受害者提交操作；而不是直接窃取数据。
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是**“冒用”**。
- 跨站请求可以用各种方式：**图片URL、超链接、CORS、Form提交等等**。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

**防护策略**：

- 阻止不明外域的访问
	- 同源检测
	- Samesite Cookie
		- Samesite=Strict:这种称为严格模式，表明这个Cookie在任何情况下都不可能作为第三方 Cookie
		- Samesite=Lax:假如这个请求是改变了当前页面或者打开了新页面且同时是个GET请求，则这个Cookie可以作为第三方Cookie
- 提交时要求附加本域才能获取的信息
	- CSRF Token  
		- 将CSRF Token输出到页面中   
		- 页面提交的请求携带这个Token    
		- 服务器验证Token是否正确，需要给每一个页面都写入Token（前端无法使用纯静态页面），每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致。这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏
		- （验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全）
	- 双重Cookie验证
		- 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。
		- 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。
		- 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。