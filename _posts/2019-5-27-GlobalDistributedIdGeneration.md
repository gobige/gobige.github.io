---
layout: post
title: '全局分布式id生成'
subtitle: '全局分布式id生成的方法'
date: 2019-05-27
categories: 
author: yates
cover: ''
tags: tips
---
 
**数据库自增长策略或字段**

方法：利用数据库生成

优点：

1. 简单，代码方便 
2. 数字id天然排序，对分页排序结果很有帮助

缺点：

1. 不同数据库实现语法不同，数据库迁移，数据库多版本支持需要处理  
2. 单个数据库或读写分离或一主多从，只有一个主库可以生成 
3. 性能达不到要求比较难扩展
4. 多系统合并，迁移难度大
5. 分库分表会有麻烦

优化：

针对主库单点，如果有多个Master，每个Master库设置起始数字不一样，步长一样

**UUID**

数据库，程序都可生成，全球唯一

优点：

1. 简单，代码方便 
2. 生成id性能比较好
3. 数据迁移，合并，从容以对

缺点：

1. 没有排序，无法保证趋势递增
2. UUID使用字符串存储，查询效率比较低
3. 存储空间比较大，如果海量数据库，就需要考虑存储量问题
4. 传输数据量大
5. 不可读

优化：

1. 使用UUID to inte64方法解决UUID不可读

2. 为了解决UUID无序的问题，NHibernate在其主键生成方式提供了Comb算法，保留10个字节，用另外6个字节表示GUID生成时间

**redis生成id**

依赖redis是单线程，可以利用其生成全局唯一ID。多redis集群，可以使用初始值不一样，步长一致的方法解决

优点：

1. 不依赖数据库,灵活方便，且性能优于数据库
2. 数字天然	排序，对分页和需要排序的结果很有帮助

缺点：

1. 须有redis组件，还有编码和配置的工作量

**snowflake**

snowflake算法是twitter开源的分布式算法。 使用41bit作为毫秒数，10bit作为机器ID（5bit数据中心 5bit机器id），12bit作为毫秒内流水号，最后一个符号位，为0

snowflake需要更具自身项目需要进行修改，比如估算未来数据中心个数，每个数据中心机器数已经统一毫秒可能并发数调整算法中所需bit数


优点：

1. 不依赖于数据库，灵活方便，且性能优于数据库
2. ID按照时间在单机上是递增的。 

缺点：

1. 分布式环境，每台机器时钟不可能完全同步，有时候会出现不是全局递增

**zookeeper生成唯一ID**

通过其znode数据版本来生成32位或64位序列号

缺点：

- 竞争较大的情况下，需要考虑使用分布式锁，
- 性能在高并发的分布式环境下，也不甚理想

**MongoDB的ObjectId**

利用ObjectId生成兼容不同机器都能使用的全局唯一id，原理和snowflake类似