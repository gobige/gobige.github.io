 ---
layout: post
title: '算法'
subtitle: '常用算法以及使用场景，实现'
date: 2018-08-23
categories: 算法
author: yates
cover: ''
tags: 算法
---

## 前言
任何定义**明确的计算步骤**都可称为**算法**，接受一个或一组值为输入，输出一个或一组值。

算法必须具备三个特性：

- **有穷性**，执行**有限步骤**后，算法必须中止。
- **确切性**，算法每个**步骤**都必须**确切定义**
- **可行性**，特点算法须可以在**特定的时间**内解决**特点问题**

- 线性表
    * [x] [数组](#array)
    * [x] [链表](#linkedList)
        + 单链表
        + 双向链表
        + 循环链表
        + 双向循环链表
        + 静态链表
    * [x] [栈](#stack) 
        + 顺序栈
        + 链式栈
    * [x] [队列](#deque) 
        * 普通队列
        * 双端队列
        * 阻塞队列
        * 并发队列
        * 阻塞并发队列
- [x] [散列表](#hashTable) 
    * 散列函数
    * 冲突解决
        * 链表法
        * 开放寻址
        * 一致性哈希
    * 动态扩容
    * [x] [位图](#map) 
- 树
    * 二叉树
        * 平衡二叉树
        * [x] [二叉查找树](#binarySearchTree) 
        * 平衡二叉查找树
            * [x] [AVL树](#avl)  
            * [x] [红黑树](#redBlackTree)  
        * 完全二叉树
        * 满二叉树
    * 多路查找树
        * [x] [B树](#b-tree) 
        * [x] [B+树](#b+-tree) 
        * [x] [B*树](#b*-tree)
        * 2-3树
        * 2-3-4树
    * [x] [堆](#heap)
        * 小顶堆
        * 大顶堆
        * 优先级队列
        * 斐波那契堆
        * 二顶堆
    * 其他
        * 树状数组
        * 线段树
* [x] [图](#map)
    * 图的存储
        * [x] [邻接矩阵](#adjacencyMatrix)
        * [x] [邻接表](#adjacencyTable)
    * 拓扑排序
    * 最短路径
    * 关键路径
    * 最小生成树
    * 二分图
    * 最大流
* 复杂度分析
    * 空间复杂度
    * 时间复杂度
        * 最好
        * 最坏
        * 平均
        * 均摊
* 基本算法思想
    * [x] [贪心算法](#greedy)
    * 分治算法
    * 动态规划
    * 回溯算法
    * 枚举算法
* 排序
    * O(N^2)
        * 冒泡排序
        * 插入排序
        * 选择排序
        * 希尔排序
    * O(nlogn)
        * 归并排序
        * 快速排序
        * 堆排序
    * O(n)
        * 计数排序
        * 桶排序
        * 基数排序
* 搜索
    * [x] [深度优先搜索](#dfs)
    * [x] [广度优先搜索](#bfs)
    * A*启发式搜索
* 查找
    * 线性表查询
    * 树结构查找
    * 散列表查找
* 字符串匹配
    * 朴素
    * [x] [KMP](#kmp)
    * [x] [Robin-Karp](#rk)
    * [x] [Boyer-Moore](#bm)
    * [x] [暴力匹配法](#bf)
    * [x] [AC自动机](#ac)
    * [x] [Trie](#trie)
    * 后缀数组
* 其他
    * 数论
    * 计算几何
    * 概率分析
    * 并查集
    * 拓扑网络
    * 矩阵运算
    * 线性规划
    
时间复杂度计算
1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大那段代码复杂度（如：多个循环最最大那个 n 5n n平方）、
3. 乘法法则 嵌套代码复杂度等于嵌套内外代码复杂度乘积

常见复杂度量级 

- $$ O(1) $$
常数级，一般算法中不存在循环语句，递归语句，即使有成千上万，复杂度也是O(1)
- $$ O(logn) $$
对数阶，不管底数为多少以此表示
```java
i=1
while(i<=n) {
    i= i*2
    // i= i*3
}
```
- $$O(2^n)$$,$$O(n)$$,$$O(nlogn)$$,$$O(2^n)$$,$$O(n!)$$,$$O(n^2)$$,$$O(n^3)$$,$$O(n^k)$$

<span id = "array"><b>数组</b></span>
**连续内存**地址，支持**随机访问**，增加，删除特定位置元素会造成，其他元素在数组中位置的移动。

<span id = "linkedList"><b>链表</b></span>
**离散内存**地址，不支持随机下标访问，因为会存储其他引用，**索引占用**内存会比数组多几倍，但是删除，增加操作的实际复杂度为O(1)；

注意：
1. 理解引用的含义 
2. 警惕指针丢失和内存泄露 
3. 利用哨兵简化实现难度 
4. 重点留意边界问题（链表为空；一个节点；两个节点；在处理头结点和尾节点的时候逻辑是否支持等情况；另外举例画图，辅助思考，多写多练）

有效的练习 
1. 单链表反转 
2. 链表中环的检测 
3. 两个有序的链表合并  
4. 删除链表倒数第几个节点 
5. 求链表的中间结点

<span id = "stack"><b>栈</b></span>
数组和链表在功能上面来说可以代替栈，但是，**数组和链表暴露太多接口**，操作上的灵活会导致使用的不可控，根据栈的**先进后出**特性适用合适的场景。用数组实现称为**顺序栈**，用链表实现称为链式栈

<span id = "deque"><b>队列</b></span>
特性为先进先出，也分为顺序队列和链式队列，主要使用场景为大部分**资源有限的场景**

<span id = "recursive"><b>递归</b></span>
利：简化代码，增加可读性；弊：需要注意的是 堆栈溢出和重复计算的问题，还有时间，空间复杂度的问题

排序算法的执行效率分析：
1. 最好情况，最坏情况，平均时间复杂度
2. 时间复杂度系数，常数，低阶
3. 比较次数和交换的次数（内存消耗，算法稳定性）

<span id = "jumpTable"><b>跳表</b></span>
链表加索引的结构，跳表索引动态更新通过一个随机函数，决定要插入的节点插入到第几级索引当中


**hash算法**

- 通过讲**任意长度二进制**值串映射为**固定长度的二进制**值串
- 作用：安全加密，唯一标识，数据校验，散列函数，负载均衡，数据分片，分布式存储

<span id = "hashTable"><b>散列表</b></span>
通过**键和值**的结构存储数据

散列函数设计：

1. 散列函数计算得到的**散列值为一个非负整数**
2. 如果key1=key2，那么hash得到的值时相等的
3. 尽量避免大量的**hash冲突**

**hash冲突解决方案**

- **开放寻址法**
    - **优点：**数据都存储在数组中，有效利用CPU缓存加快查询速度；序列化比较简单；
    - **缺点：**冲突代价更高，开放寻址法，装载因子上限不能太大
    - **适用场景：**数据量比较小，装载因子小的场景
- **链表法**: 链表节点可以在需要的时候在创建，对大装载因子的容忍度更高，即使变成链表后，只是查询速度有所下降，能够有效的避免散列碰撞攻击

- **一致性哈希算法**:
一致性hash算法用于解决**分布式缓存数据**分布问题，传统的哈希算法下，每条缓存数据落在那个节点是通过哈希算法和服务器节点数量计算出来的，一旦服务器节点数量发生增加或者介绍，哈希值需要重新计算，此时几乎所有的数据和服务器节点的对应关系也会随之发生变化
    - 首先将哈希空间映射到一个**虚拟的环**上，环上的数值分从 0 到 2^32-1，使用同样的哈希算法将缓存服务节点（通常通过服务器IP+端口作为节点的key）和数据键映射到环上的位置
    - 使用一致的方向（比如顺时针方向）沿环查找，遇到的第一个有效服务器就是缓存保存的地方，这样失效的缓存就会很少，在实体服务器不增加的情况下，用多个虚拟节点替代原来的单个实体节点，一台服务服务器在环上就对应多个位置，这样可以让数据存储更加均匀，各服务器的负载页更加平衡

- **工业级散列函数**
    - 支持快速查询，插入，删除
    - 内存占用合理，不能浪费过多内存空间
    - 性能稳定，极端情况下，性能也不会退化到无法接受的情况

**动态扩容**：

- 不要求当原有数组空间不足时，一次性扩展数组的容量，**新建**一个**散列表**，**新旧数据结构一起使用**，**逐步转移**原有数据到新空间

**LRU缓存淘汰算法**

- 通过**散列表和双向链表**的组合使用可以做到在缓存中的添加，删除，查找数据的时间复杂度为O(1) ，如LinkedHashMap

二叉树存储方法：

- 链式存储法，平常所见**大多数二叉树的结构**
- 顺序存储法，把根结点存储在下标i=1的位置，左子节点存储在下标2*i的位置，右子节点存储在2*i+1的位置（由此而见，这种方式如果存储的非完全二叉树，那么就会**浪费数组很多存储**空间，完全二叉树只会浪费下标为0的一个位置）

<span id = "binarySearchTree"><b>二叉查找树</b></span>

- 增加，查询，最大，最小，都是高效的，**删除**情况比**较复杂**，分是否有节点有不同处理方式，同时二叉查找树通过**中序遍历**可以得到**有序序列**。
- **重复数据**的二叉查找树**存储处理**，
    1. 链表 
    2. 重复数据放到右节点，查询，删除的时候要求一直遍历右节点，**直到不等值**

**散列表和二叉树区别**：

- 散列表中数据是**无序存储**的，要输出有序数据，需先进行排序。对应二叉查找树，只需中序遍历即可，时间复杂度为O(n)
- **散列表扩容耗时很多**，当遇到冲突时，性能不稳定，二叉查找树中平衡二叉树，时间复杂度文档在O(logn)
- 散列表时间复杂度是常量级的，加上hash计算的耗时，不一定比平衡二叉查找树效率高
- 散列表需要考虑散列算法，扩容，缩容，装载因子等众多复杂因素
 

<span id = "avl"><b>平衡二叉树</b></span>

- 具有二叉查找树特性
- 左右两个子树的高度差的绝对值不超过1（插入或删除节点，需要对节点进行旋转）
- 单旋转-双旋转


<span id = "redBlackTree"><b>红黑树</b></span>

- 是一个具有特点的平衡二叉树（为了保持平衡需要不断旋转节点，代价可能太高）
- 节点是红色或者是黑色
- 根节点是黑色
- 每个叶节点（NIL或空节点）是黑色
- 每个红色节点的两个子节点都是黑色的
- 从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点
- 旋转操作为了保证上述特征
- **不一定完全平衡**，最优平衡，O(log2 n)的时间复杂度，节点旋转,三次旋转之内解决

AVL和红黑树随着树高度增加查询性能降低

<span id = "B-tree"><b>B树</b></span>

是一种多路搜索树，下面m指的是m阶B树，为了进一步降低树的高度

- 树中每个结点最多含有m个孩子（m>=2）
- 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子 [M/2, M]
- 根结点至少有2个孩子 [2, M]
- 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息
- 每个非根节点所包含的关键字个数 j 满足：（m/2） - 1 <= j <= m - 1
- 除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：（m/2） <= k <= m 
- 非叶子结点的关键字个数=指向儿子的指针个数-1
- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]
- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树
- 所有叶子结点位于同一层
- 特性
	1. **关键字**集合**分布**在**整颗树**中；
	2. 任何一个**关键字**出现且**只**出现在**一个结点**中；
	3. **搜索**有可能在**非叶子结点结束**；
	4. 其搜索**性能**等价于在关键字全集内做一次**二分查找**；
	5. 自动层次控制；
	
无线多路的多路树又会导致结构退化成有序数组
 
文件系统和数据库索引都是存在硬盘的，如果数据量太大，不一定能一次性读取到内存。而通过每次加载B树的一个节点，然后一步步往下找、

	
<span id = "B+-tree"><b>B+树</b></span>
 
- 定义
    - 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点
    - 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
    - 所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。 通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点 
- 与B树的差异
    - 非叶子结点的子树指针与关键字个数相同；
    - 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树
    - （B树是开区间）；
    - 为所有叶子结点增加一个链指针；
    - 所有关键字都在叶子结点出现；

- 特性
    - 所有**关键字**都出现在**叶子结点的链表**中（稠密索引），且链表中的关键字恰好是**有序**的；
    - 不可能在非叶子结点命中；
    - **非叶子结点**相当于是叶子结点的索引（**稀疏索引**），**叶子结点**相当于是**存储（关键字）数据**的数据层；
    - 更适合**文件索引系统**；

由于数据都在叶子节点，而且**叶子节点**之间还是用指针形成了**链表**，所以很适合使用像数据库这种根据**条件查询多条记录**的文档系统
	
	
<span id = "B*-tree"><b>B*树</b></span>
 
- 与B+树的差异
    - 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针
- 定义
    - 非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3


### B树 B+树 B*树小结：

B树
多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；
所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

B+树
在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点
中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

B*树
在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；


**递归树**

- 通过将大问题分解为小问题进行求解，一层一层分解可比做一棵树

<span id = "heap"><b>堆</b></span>

- 必须是完全二叉树
- 堆中每个节点值必须大于等于其子树每个节点的值（或小于）
- 堆化： 堆中元素插入和删除后，需要进行调整，让其满足堆的特性，这个过程叫做堆化（从下往上，或从上往下进行元素删除，增加，每个节点进行对比，交换位置）。
- 应用
    - 优先级队列
    - 合并有序小文件（入堆，出堆）
    - 高性能定时器（始终拿堆顶数据）
    - 利用堆求TOP k
        - 静态
        - 动态
    - 利用堆求中位数
        - 静态 第n/2个数据就是中位数
        - 动态 维护两个堆，一个大顶堆，一个小顶堆，分别存储前半，后半部分数据
    - 求百分比数

**堆排序和快速排序**：

1. 堆排序数据访问方式没有快速排序友好，前者跳着访问的，对**cpu缓存不友好**
2. 对于同样数据，在排序过程中，**堆排序的数据交换次数要多于快速排序**

<span id = "map"><b>图</b></span>

- 构造：
    - 顶点：图中的元素称作顶点
    - 边：顶点与顶点之间建立的联系关系
    - 度：每个顶点有多少条边关联，叫做顶点的度
- 分类： 
    - 有向图：某个节点关注某个节点，不关注其他节点，分为入度和出度
    - 无向图：节点之间互相关注
    - 带权图：每条边都有一个权重，可以通过权重表示每个顶点之间的热度
- 存储：
    - <span id="adjacencyMatrix"><b>邻接矩阵</b></span>,底层为一个**二维数组**。如果顶点i和顶点j之间**有边**。那么就将A[i][j]和A[j][i]赋值为1，有向图，带权图相应进行赋值
        - 容易导致**空间浪费**，比如无向图和稀疏图；优点是**存储方式简单，方便计算**
    - <span id="adjacencyTable"><b>邻接表</b></span>,每个**顶点**对应一条**链表**，链表中存储这个**顶点相连其他顶点**。适用于微博，微信等**好友互关**的场景（使用hash算法进行**数据分片**，再把数据进行邻接表存储，使用**外部存储数据库存储索引**）
    - 逆邻接表 

**搜索算法**
大部分设计搜索的场景都可以抽象成图

<span id="bfs"><b>广度优先搜索BFS</b></span>

- 先查找离顶点**最近**的，然后是**次近**的。依次**往外搜索**，**最终得到最短路径**
    - 如：s表示起始顶点，t表示终止顶点；使用一个visited数组表示所有顶点，通过赋值表示十分被访问；queue队列用来存储表示已经被访问，但**相连顶点**还没有被访问的顶点；prev用来记录搜索路径，反向存储路径


<span id="dfs"><b>深度优先搜索DFS</b></span>

- 寻址从起始顶点s到终止顶点t的路径，把整个搜索路径标记出来，**实线**表示**遍历**，**虚线**表示**回退**。但是得到的搜索路径并**不一定是最短路径**

**字符串匹配算法**

trie树与散列表，红黑树都可以实现字符串匹配的问题

假如我们要在主字符串A中查找字符模式串B。


<span id="bf"><b>BF算法</b></span>

- 主串长度记作n，模式串长度记作m。我们在**主串中**，检查起始位置1,2,3,4...n-m且长度为m的**n-m+1个子串**，看有没有跟模式串匹配的，俗称**暴力匹配**。
    - **时间复杂度**:O(n*m)，但是从统计上来看实际执行效率是不会很差的。**思想简单，符合KISS原则**

<span id="RK"><b>RK算法</b></span>

- 通过将主串中的所有**子串hash**，与模式串进行匹配
    - 可以通过优化hash计算，相邻两个子串具有**重叠**的字符部分，得到的hash值是一样的

<span id="bm"><b>BM算法</b></span>

- 模式串在匹配过程中与主串**多位匹配移动**
    1. **坏字符**规则，模式串和主串匹配时，按照模式串下标**从大到小**顺序进行匹配。当我们发现某个字符没法匹配时，把这个**没有匹配的字符**称为**坏字符**。当发生不匹配时，坏字符对应模式串中字符下**标记作si**。如果坏字符在**模式串**中存在，这个下**标记作xi**，不存在xi记作-1.模式串向后**移动位数等于si-xi**
        - 坏字符在模式串中遍历查找时，会很低效，可以将模式串中的字符及其下标存储到散列表中。这样就可以快速找到坏字符在模式串中位置下标
    2. **好后缀**规则，已经匹配的字符叫作好后缀，记作**{u}**，我们拿它在模式串中查找，如果找到另一个跟{u}相匹配的子串{u*}，我们就将模式串滑动到子串{u*}与主串中{u}对其的位置，但是这样很可能导致**过度移动**，导致好后缀中部分字符串与模式串中前缀字符匹配的丢失


<span id="kmp"><b>KMP算法</b></span>

- KMP试图在模式串和主串匹配的过程中，当遇到坏字符后，对于已经对比过的好前缀，将模式串一次性滑动很多位

<span id="trie"><b>Trie树</b></span>

- Trie树，也叫“字典树”。Trie树的本质，就是利用**字符串之间的公共前缀**，将重复的前缀合并在一起.Trie树将每次查找**字符串分解为字符**，从根结点开始，沿着某条路就匹配。一个字符串一条路径。尾节点为一个字符串的结束。
    - 通过hash表，存储字符的hash到对应的数组下标。时间复杂度为O(n)，空间复杂度为O(26的n次方)
    - 要求字符串包含字符集不能太多，会造成大量空间的浪费
    - 字符串前缀重合比较多
    - 指针串起来的数据块不是连续的，对缓存不友好

<span id="acAuto"><b>AC自动机</b></span>

- 针对大量字符串过滤，Trie树可以做到多模式串匹配，我们把用户输入内容作为主串从第一个字符开始匹配，当匹配到Trie树叶子节点或中途遇到不匹配字符时，将主串开始匹配位置后移，重新再Tire树中匹配。那么这个后移也可以想KMP算法一样进行优化。

AC自动机通过在Trie树上，加了类似KMP的next数组


<span id="acAuto"><b>贪心算法</b></span>

- 定义**限制值和期望值**，数据在**满足限制值**情况下**最大化期望值**
- 贪心算法能解决问题，但是**不一定是最优解**（因为前面的**选择**会**影响**后面的**选择**）