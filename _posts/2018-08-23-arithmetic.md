---
layout: post
title: '算法'
subtitle: '常用算法以及使用场景，实现'
date: 2018-08-23
categories: 算法
author: yates
cover: ''
tags: 算法
---

## 前言
任何定义明确的计算步骤都可称为**算法**，接受一个或一组值为输入，输出一个或一组值。

算法必须具备三个特性,分别是：

- **有穷性**，执行有限步骤后，算法必须中止。
- **确切性**，算法每个步骤都必须确切定义
- **可行性**，特点算法须可以在特定的时间内解决特点问题

- 线性表
    * 数组
    * 链表
        + 单链表
        + 双向链表
        + 循环链表
        + 双向循环链表
        + 静态链表
    * 栈
        + 顺序栈
        + 链式栈
    * 队列
        * 普通队列
        * 双端队列
        * 阻塞队列
        * 并发队列
        * 阻塞并发队列
- 散列表
    * 散列函数
    * 冲突解决
        * 链表法
        * 开发寻址
        * 其他
    * 动态扩容
    * 位图
- 树
    * 二叉树
        * 平衡二叉树
        * 二叉查找树
        * 平衡二叉查找树
            * AVL树
            * 红黑树
        * 完全二叉树
        * 满二叉树
    * 多路查找树
        * B树
        * B+树
        * 2-3树
        * 2-3-4树
    * 堆
        * 小顶堆
        * 大顶堆
        * 优先级队列
        * 斐波那契堆
        * 二顶堆
    * 其他
        * 树状数组
        * 线段树
* 图
    * 图的存储
        * 邻接矩阵
        * 邻接表
    * 拓扑排序
    * 最短路径
    * 关键路径
    * 最小生成树
    * 二分图
    * 最大流
* 复杂度分析
    * 空间复杂度
    * 时间复杂度
        * 最好
        * 最坏
        * 平均
        * 均摊
* 基本算法思想
    * 贪心算法
    * 分治算法
    * 动态规划
    * 回溯算法
    * 枚举算法
* 排序
    * O(N^2)
        * 冒泡排序
        * 插入排序
        * 选择排序
        * 希尔排序
    * O(nlogn)
        * 归并排序
        * 快速排序
        * 堆排序
    * O(n)
        * 计数排序
        * 桶排序
        * 基数排序
* 搜索
    * 深度优先搜索
    * 广度优先搜索
    * A*启发式搜索
* 查找
    * 线性表查询
    * 树结构查找
    * 散列表查找
* 字符串匹配
    * 朴素
    * KMP
    * Robin-Karp
    * Boyer-Moore
    * AC自动机
    * Trie
    * 后缀数组
* 其他
    * 数论
    * 计算几何
    * 概率分析
    * 并查集
    * 拓扑网络
    * 矩阵运算
    * 线性规划
    
时间复杂度计算
1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大那段代码复杂度（如：多个循环最最大那个 n 5n n平方）、
3. 乘法法则 嵌套代码复杂度等于嵌套内外代码复杂度乘积

常见复杂度量级 

- $$ O(1) $$
常数级，一般算法中不存在循环语句，递归语句，即使有成千上万，复杂度也是O(1)
- $$ O(logn) $$
对数阶，不管底数为多少以此表示
```java
i=1
while(i<=n) {
    i= i*2
    // i= i*3
}
```
- $$O(2^n)$$,$$O(n)$$,$$O(nlogn)$$,$$O(2^n)$$,$$O(n!)$$,$$O(n^2)$$,$$O(n^3)$$,$$O(n^k)$$

    
数组：连续内存地址，支持随机下标访问，增加，删除特定位置元素会造成，其他元素在数组中位置的移动。

链表：离散内存地址，不支持随机下标访问，因为会存储其他引用，索引占用内存会比数组多几倍，但是删除，增加操作的实际复杂度为O(1)；

链表实现代码需要注意几点：1理解引用的含义 2警惕指针丢失和内存泄露 3利用哨兵简化实现难度 4重点留意边界问题（链表为空；一个节点；两个节点；在处理头结点和尾节点的时候逻辑是否支持等情况；另外举例画图，辅助思考，多写多练）

链表中几个极具操作有效的练习 1 单链表反转 2 链表中环的检测 3 两个有序的链表合并  4 删除链表倒数第几个节点 5求链表的中间结点

栈：数组和链表在功能上面来说可以代替栈，但是，数组和链表暴露太多借口，操作上的灵活会导致使用的不可控，根据栈的**先进后出**特性适用合适的场景。用数组实现称为顺序栈，用链表实现称为链式栈

队列：特性为先进先出，也分为顺序队列和链式队列，主要使用场景为大部分资源有限的场景

递归：利：简化代码，增加可读性；弊：需要注意的是 堆栈溢出和重复计算的问题，还有时间，空间复杂度的问题

排序算法的执行效率分析：
1. 最好情况，最坏情况，平均时间复杂度
2. 时间复杂度系数，常数，低阶
3. 比较次数和交换的次数（内存消耗，算法稳定性）

跳表：
链表加索引的结构，跳表索引动态更新通过一个随机函数，决定要插入的节点插入到第几级索引当中

散列表：
通过键和值的结构存储数据，
散列函数设计基本要求
1. 散列函数计算得到的散列值为一个非负整数
2. 如果key1=key2，那么hash得到的值时相等的
3. 尽量避免大量的hash冲突

hash冲突解决方案
- 开放寻址法：**优点** 数据都存储在数组中，有效利用CPU缓存加快查询速度；序列化比较简单；**缺点** 冲突代价更高，开放寻址法，装载因子上限不能太大 综上所述：开放寻址法适合数据量比较小，装载因子小的情况
- 链表法 链表节点可以在需要的时候在创建，对大装载因子的容忍度更高，即使变成链表后，只是查询速度有所下降，能够有效的避免散列碰撞攻击

工业级散列函数：

- 支持快速查询，插入，删除
- 内存占用合理，不能浪费过多内存空间
- 性能稳定，极端情况下，性能也不会退化到无法接受的情况

动态扩容：
不要求当原有数组空间不足时，一次性扩展数组的容量，新建一个散列表，新旧数据结构一起使用，逐步转移原有数据到新空间

LRU缓存淘汰算法
通过散列表和双向链表的组合使用可以做到在缓存中的添加，删除，查找数据的时间复杂度为O(1) 

LinkedHashMap是通过双向链表和散列表者2两种数据结构组合实现的

hash算法：通过讲任意长度二进制值串映射为固定长度的二进制值串。

hash算法的作用：
安全加密，唯一标识，数据校验，散列函数，负载均衡，数据分片，分布式存储

二叉树存储方法：

- 链式存储法，平常所见大多数二叉树的结构
- 顺序存储法，把根结点存储在下标i=1的位置，左子节点存储在下标2*i的位置，右子节点存储在2*i+1的位置（由此而见，这种方式如果存储的非完全二叉树，那么就会浪费数组很多存储空间，完全二叉树只会浪费下标为0的一个位置）

二叉查找树，增加，查询，最大，最小，都是高效的，删除情况比较复杂，分是否有节点有不同处理方式，同时二叉查找树通过中序遍历可以得到有序序列。重复数据的二叉查找树存储处理，1.链表 2重复数据放到右节点，查询，删除的时候要求一直遍历右节点，直到不等值

散列表和二叉树：

- 散列表中数据是无序存储的，要输出有序数据，需先进行排序。对应二叉查找树，只需中序遍历即可，时间复杂度为O(n)
- 散列表扩容耗时很多，当遇到冲突时，性能不稳定，二叉查找树中平衡二叉树，时间复杂度文档在O(logn)
- 散列表时间复杂度是常量级的，加上hash计算的耗时，不一定比平衡二叉查找树效率高
- 散列表需要考虑散列算法，扩容，缩容，装载因子等众多复杂因素

红黑树不一定完全平衡，最优平衡，红黑树的平衡方法，节点旋转

递归树：通过将大问题分解为小问题进行求解，一层一层分解可比做一棵树

堆： 1 必须是完全二叉树，2 堆中每个节点值必须大于等于其子树每个节点的值（或小于）

堆化： 堆中元素插入和删除后，需要进行调整，让其满足堆的特性，这个过程叫做堆化。
从下往上，或从上往下进行元素删除，增加，每个节点进行对比，交换位置。

堆排序和快速排序：

1. 堆排序数据访问方式没有快速排序友好，前者跳着访问的，对cpu缓存不友好
2. 对于同样数据，在排序过程中，堆排序的数据交换次数要多于快速排序

堆的应用：

- 优先级队列
    - 合并有序小文件（入堆，出堆）
    - 高性能定时器（始终拿堆顶数据）
- 利用堆求TOP k
    - 静态
    - 动态
- 利用堆求中位数
    - 静态 第n/2个数据就是中位数
    - 动态 维护两个堆，一个大顶堆，一个小顶堆，分别存储前半，后半部分数据
- 求百分比数

图：

- 顶点：图中的元素称作顶点
- 边：顶点与顶点之间建立的联系关系
- 度：每个顶点有多少条边关联，叫做顶点的度

有向图：某个节点关注某个节点，不关注其他节点，分为入度和出度
无向图：节点之间互相关注
带权图：每条边都有一个权重，可以通过权重表示每个顶点之间的热度

图的存储：

- 邻接矩阵，底层为一个二维数组。如果顶点i和顶点j之间有边。那么就将A[i][j]和A[j][i]赋值为1，有向图，带权图相应进行赋值

邻接矩阵很容易导致空间的浪费，比如无向图和稀疏图；优点是存储方式简单，方便计算

- 邻接表，每个顶点对应一条链表，链表中存储这个顶点与之相连的其他顶点

微博，微信等好友互关的场景，适合使用**邻接表，逆邻接表**。使用hash算法进行**数据分片**，再把数据进行邻接表存储，使用**外部存储数据库存储索引**

搜索算法
大部分设计搜索的场景都可以抽象成图

- 广度优先搜索BFS：先查找离顶点最近的，然后是次近的。依次往外搜索，最终得到最短路径
如：s表示起始顶点，t表示终止顶点；使用一个visited数组表示所有顶点，通过赋值表示十分被访问；queue队列用来存储表示已经被访问，但**相连顶点**还没有被访问的顶点；prev用来记录搜索路径，反向存储路径

- 深度优先搜索DFS：寻址从起始顶点s到终止顶点t的路径，把整个搜索路径标记出来，实线表示遍历，虚线表示回退。但是得到的搜索路径并不一定是最短路径

字符串匹配算法

- BF算法：
假如我们要在字符串A中查找字符串B。首先，定义主串（A）和模式串(B)，主串长度记作n，模式串长度记作m。**我们在主串中，检查起始位置1,2,3,4...n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的**，俗称暴力匹配。最坏时间复杂度为O(n*m)，但是从统计上来看实际场景下算法执行效率是不会很差的。思想简单，符合KISS原则
- RK算法：
通过将主串中的所有子串继续hash，与模式串进行匹配

可以通过优化hash计算，相邻两个子串具有重叠的字符部分，得到的hash值是一样的

- BM算法：主要通过模式串在与主串匹配移动过程中，多位移动

1. 坏字符规则，模式串和主串匹配时，按照模式串下标**从大到小**顺序进行匹配。当我们发现某个字符没法匹配时，把这个没有匹配的字符称为**坏字符**。当发生不匹配时，坏字符对应模式串中字符下标记作si。如果坏字符在模式串中存在，这个下标记作xi，不存在xi记作-1.模式串向后移动位数等于si-xi
2. 好后缀规则
我们把已经匹配的字符叫作好后缀，记作{u}，我们拿它在模式串中查找，如果找到另一个跟{u}相匹配的子串{u*}，我们就将模式串滑动到子串{u*}与主串中{u}对其的位置，但是这样很可能导致过度移动，导致好后缀中部分字符串与模式串中前缀字符匹配的丢失

坏字符在模式串中遍历查找时，会很低效，可以将模式串中的字符及其下标存储到散列表中。这样就可以快速找到坏字符在模式串中位置下标


- KMP算法
KMP试图在模式串和主串匹配的过程中，当遇到坏字符后，对于已经对比过的好前缀，将模式串一次性滑动很多位

- Trie树
Trie树，也叫“字典树”。Trie树的本质，就是利用**字符串之间的公共前缀**，将重复的前缀合并在一起.Trie树将每次查找字符串分解为字符，从根结点开始，沿着某条路就匹配。一个字符串一条路径。尾节点为一个字符串的结束。

如何快速找到子节点的指针，通过hash表的思想，存储字符的hash到对应的数组下标。时间复杂度为O(n)，空间复杂度为O(26的你n次方)

trie树与散列表，红黑树都可以实现字符串匹配的问题

1Trie树要求字符串包含字符集不能太多，会造成大量空间的浪费2要求字符串前缀重合比较多3通过指针串起来的数据块不是连续的，对缓存不友好

AC自动机
针对大量字符串过滤，Trie树可以做到多模式串匹配，我们把用户输入内容作为主串从第一个字符开始匹配，当匹配到Trie树叶子节点或中途遇到不匹配字符时，将主串开始匹配位置后移，重新再Tire树中匹配。那么这个后移也可以想KMP算法一样进行优化。

AC自动机通过在Trie树上，加了类似KMP的next数组

- 贪心算法
1. 定义限制值和期望值，数据在满足限制值情况下最大化期望值

贪心算法能解决问题，但是不一定是最优解（因为前面的选择会影响后面的选择）