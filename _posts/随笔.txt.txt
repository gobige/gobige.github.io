表中存的数据注意其价值，像三方接口得到的数据随时可能会变的，不宜在该表中添加一些自定义字段，容易造成以后调用接口就会考虑其是不是应该赋值
表结构中禁止one，two，three等字段，应该使用一对多的表存储



商品审核这种，因为涉及的比较多，对于增加和修改商品如果使用拷贝一份主表的数据拿出修改，让后审核通过后覆盖现有的表的，会导致问题1表关联比较复杂2供应商添加的商品需要看到（即使还在审核中），基于商品表数量不像订单表一样大数据量，采用修改，增加内容直接在主表操作，通过增加额外的标识字段来区别，如果通过，就是用修改的数据覆盖现有数据


一对多的关系，一对一关系，多对多关系？？？

当要使用 useGeneratedKeys 返回生成记录的主键时，下列的dao接口映射，是返回不了主键id的
    void insertOssDepartment(@Param("item") OssDepartment item);

正确做法是
    void insertOssDepartment(OssDepartment item);


new ArrayList<>(3) 这种赋值方式是赋值集合的大小，而不是3作为元素赋值


集合中获取迭代器iterator时必须加上泛型声明类，不然迭代是无法进行删除等操作

java中的service是单例的，方法如果没加锁都是可重入的。


mq 不能传递 date类型参数
mq 必须有默认构造函数

mq的编写 一定要分清什么事次要的可以放后的,而不是所有的东西都适用mq,

 
collector.toMap,这个lambd表达式坑很多，key,value不能为空，key，value不能重复
    (k,v)->v  支持map集合插入重复数据时覆盖原有数据,

git rebase 是一个危险命令，因为它改变了历史，我们应该谨慎使用。
除非你可以肯定该 feature1 分支只有你自己使用，否则请谨慎操作。
结论：只要你的分支上需要 rebase 的所有 commits 历史还没有被 push 过，就可以安全地使用 git-rebase来操作。


idea java文件显示J不显示C,用maven引入方式

如果使用mybatis中的CRUD注解@select,在没有xml配置映射的情况下使用的是全局驼峰映射,那么domain对象的属性对应数据库字段一定要规范;或者使用@Results @Result 注解填写映射关系

mysql中的join用法
join对查询条件如果是多对多的关系,则进行笛卡尔乘积运算
inner join : 内联两张关联表,将符合条件的两张关联表中记录进行展示
left join : 左连接查询会返回左表中所有记录，不管右表中有没有关联的数据, 
right join : 右连接查询会返回右表中所有记录，不管左表中有没有关联的数据, 
FULL OUTER JOIN   外连接查询能返回左右表里的所有记录，其中左右表里能关联起来的记录被连接后返回
LEFT JOIN EXCLUDING INNER JOIN   返回左表有但右表没有关联数据的记录集
RIGHT JOIN EXCLUDING INNER JOIN   返回右表有但左表没有关联数据的记录集
FULL OUTER JOIN EXCLUDING INNER JOIN 返回左表和右表里没有相互关联的记录集。

LocalDateTime.parse 只能解析年月日 时分秒格式的字符串,不能解析单独只有年月日的格式


面对关系很复杂的表关联设计时,使用中间关联表,关联各表之间的联系

页面配置问题：很多需要先删除，再增加的逻辑，在高并发的情况下会导致，删除不到应该删除的数据，导致问题，1前端按钮失效控制  2后端接口请求频率控制

mq在使用的时候 因为 有重试的机制 在调用服务的时候，服务一定要可靠（简单，稳定，不会有太多复杂逻辑），而且带事务回滚，如果失败会不断重试，如果没有回滚会导致许多脏数据，如果调用无法回滚的三方接口，那么一定要在mq里面进行异常处理，避免不断重试


类似于一张表的操作一定要搞明白每一个字段的含义，特别是流程特别多个流程设计修改一张表数据的时候，要考虑各种各样的情况。但是不建议一张表代表的含义过多，比如库价，库存表，普通商品库存操作会修改，活动商品操作也会修改，指不定哪个流程就就互相影响了，所以表能独立最好还是独立，如果为了性能什么，需要融合到一张表，1 一定要搞清楚这张表每个字段含义，2已经涉及表修改的所有功能业务熟系，以便去写相应的处理逻辑。


zookeeper 是基于CP的，euraka是基于CA的，zokeeper有master，slave之分，如果正在选主或集群半数以上机器不可用，那么zookeeper无法保证服务的可用；而Euraka没有，采用peer to peer通信，节点彼此互相注册提高可用性。即使所有节点都挂了，也能通过本地得到缓存数据。根据两者区别来选择合适的注册中心

spring对每个bean提供一个scope属性表示bean的作用域，这些bean大多是无状态对象。single类型的无状态bean都是线程安全的，例如每个dao提供的方法都只是对数据的CURD，每个数据库connection都作为函数局部变量，处于栈中，属于线程私有的内存区域，用完即回收。每个controller被多个线程执行，springmvc对请求拦截粒度时基于每个方法（而struct2时基于类，也就是多例controller，频繁创建，回收，影响性能）。spring没有对bean的多线程安全作出任何保证和措施，所以我们在bean的设计中声明任何有状态的实例变量和类变量，如果非得有，则要使用ThreadLocal变量私有化或使用synchronized，lock，cas等实现线程同步方法

数据库基概：单库-分组（线性提升数据库读性能，消除读写锁，提升写性能；读高可用）-分片（分表依然公用一个数据库文件，仍有磁盘IO竞争；分库容易数据迁移不同数据库实例，扩展好）（线性提升数据库写能力，降低单库容量）-垂直切分（降低单库容量，降低磁盘IO，跟业务紧密相关）

使用spring-session 和 redis 实现 session集群共享

for循环改写 for(int i = 0; int temp = xxx.size();i  temp;i++)
引起FULL GC原因，老年代不够用了，永久代元空间不够用了，system.gc
 

jdk动态代理是基于接口代理，而CGLIB则不是
spring 5.x 中AOP默认使用JDK动态代理

springboot 2.x默认使用CGLIB，要想使用JDK 配置项  spring.aop.proxy-target-class=false
 
除了构造注入会导致强依赖以外，一个bean也会强依赖于暴露他的配置类。不要对有@configuration注解的配置类进行field级的依赖注入


hikaricp连接池的使用，spring 事务利用AOP原理进行round的方法增强，增强方法调用内部方法时，必须通过引用XXservice.method方法调用才会是事务生效，否则不生效

幂等

1. 查询操作
2. 删除操作
3. 唯一索引，防止新增脏数据
4. token机制
防止页面重提交：
集群环境：采用token加redis；
单机环境token加jvm内存；
处理流程： 1.数据提交前服务器申请token，token放到redis或内存，设置token有效时间 2提交后验证token并删除，表示验证成功并生成新token返回；注意：select+update很容易造成并发问题。应直接采用delete操作并判断执行结果

5. 悲观锁
6. 乐观锁
	- 版本号
	- 条件限制
	- 分布式锁
	- select insert：并发不高的环境，如管理员后台等操作使用
	- 状态机：比如任务，审核流程流转等，上一个状态无法在下一个状态之后发生等
	- 对外提供接口，如付款，通过提交请求的附带 source来源，seq序列号决定唯一性
	
@cacheevict方法和@transactional事务同时用的情况下很可能导致redis刷新缓存失败，参考aop round就像一层一层的包裹与解开必然执行顺序和提交顺序会有差别，解决方案：缩小事务范围

spring升级时 默认Integer和date是不能互相转换，会报错，而之前版本时可以的
