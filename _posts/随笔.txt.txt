表中存的数据注意其价值，像三方接口得到的数据随时可能会变的，不宜在该表中添加一些自定义字段，容易造成以后调用接口就会考虑其是不是应该赋值
表结构中禁止one，two，three等字段，应该使用一对多的表存储



商品审核这种，因为涉及的比较多，对于增加和修改商品如果使用拷贝一份主表的数据拿出修改，让后审核通过后覆盖现有的表的，会导致问题1表关联比较复杂2供应商添加的商品需要看到（即使还在审核中），基于商品表数量不像订单表一样大数据量，采用修改，增加内容直接在主表操作，通过增加额外的标识字段来区别，如果通过，就是用修改的数据覆盖现有数据


一对多的关系，一对一关系，多对多关系？？？

当要使用 useGeneratedKeys 返回生成记录的主键时，下列的dao接口映射，是返回不了主键id的
    void insertOssDepartment(@Param("item") OssDepartment item);

正确做法是
    void insertOssDepartment(OssDepartment item);


new ArrayList<>(3) 这种赋值方式是赋值集合的大小，而不是3作为元素赋值


集合中获取迭代器iterator时必须加上泛型声明类，不然迭代是无法进行删除等操作

java中的service是单例的，方法如果没加锁都是可重入的。


mq 不能传递 date类型参数
mq 必须有默认构造函数

mq的编写 一定要分清什么事次要的可以放后的,而不是所有的东西都适用mq,

 
collector.toMap,这个lambd表达式坑很多，key,value不能为空，key，value不能重复
    (k,v)->v  支持map集合插入重复数据时覆盖原有数据,

git rebase 是一个危险命令，因为它改变了历史，我们应该谨慎使用。
除非你可以肯定该 feature1 分支只有你自己使用，否则请谨慎操作。
结论：只要你的分支上需要 rebase 的所有 commits 历史还没有被 push 过，就可以安全地使用 git-rebase来操作。


idea java文件显示J不显示C,用maven引入方式

如果使用mybatis中的CRUD注解@select,在没有xml配置映射的情况下使用的是全局驼峰映射,那么domain对象的属性对应数据库字段一定要规范;或者使用@Results @Result 注解填写映射关系

mysql中的join用法
join对查询条件如果是多对多的关系,则进行笛卡尔乘积运算
inner join : 内联两张关联表,将符合条件的两张关联表中记录进行展示
left join : 左连接查询会返回左表中所有记录，不管右表中有没有关联的数据, 
right join : 右连接查询会返回右表中所有记录，不管左表中有没有关联的数据, 
FULL OUTER JOIN   外连接查询能返回左右表里的所有记录，其中左右表里能关联起来的记录被连接后返回
LEFT JOIN EXCLUDING INNER JOIN   返回左表有但右表没有关联数据的记录集
RIGHT JOIN EXCLUDING INNER JOIN   返回右表有但左表没有关联数据的记录集
FULL OUTER JOIN EXCLUDING INNER JOIN 返回左表和右表里没有相互关联的记录集。

LocalDateTime.parse 只能解析年月日 时分秒格式的字符串,不能解析单独只有年月日的格式


面对关系很复杂的表关联设计时,使用中间关联表,关联各表之间的联系

页面配置问题：很多需要先删除，再增加的逻辑，在高并发的情况下会导致，删除不到应该删除的数据，导致问题，1前端按钮失效控制  2后端接口请求频率控制

mq在使用的时候 因为 有重试的机制 在调用服务的时候，服务一定要可靠（简单，稳定，不会有太多复杂逻辑），而且带事务回滚，如果失败会不断重试，如果没有回滚会导致许多脏数据，如果调用无法回滚的三方接口，那么一定要在mq里面进行异常处理，避免不断重试


类似于一张表的操作一定要搞明白每一个字段的含义，特别是流程特别多个流程设计修改一张表数据的时候，要考虑各种各样的情况。但是不建议一张表代表的含义过多，比如库价，库存表，普通商品库存操作会修改，活动商品操作也会修改，指不定哪个流程就就互相影响了，所以表能独立最好还是独立，如果为了性能什么，需要融合到一张表，1 一定要搞清楚这张表每个字段含义，2已经涉及表修改的所有功能业务熟系，以便去写相应的处理逻辑。


zookeeper 是基于CP的，euraka是基于CA的，zokeeper有master，slave之分，如果正在选主或集群半数以上机器不可用，那么zookeeper无法保证服务的可用；而Euraka没有，采用peer to peer通信，节点彼此互相注册提高可用性。即使所有节点都挂了，也能通过本地得到缓存数据。根据两者区别来选择合适的注册中心

spring对每个bean提供一个scope属性表示bean的作用域，这些bean大多是无状态对象。single类型的无状态bean都是线程安全的，例如每个dao提供的方法都只是对数据的CURD，每个数据库connection都作为函数局部变量，处于栈中，属于线程私有的内存区域，用完即回收。每个controller被多个线程执行，springmvc对请求拦截粒度时基于每个方法（而struct2时基于类，也就是多例controller，频繁创建，回收，影响性能）。spring没有对bean的多线程安全作出任何保证和措施，所以我们在bean的设计中声明任何有状态的实例变量和类变量，如果非得有，则要使用ThreadLocal变量私有化或使用synchronized，lock，cas等实现线程同步方法

数据库基概：单库-分组（线性提升数据库读性能，消除读写锁，提升写性能；读高可用）-分片（分表依然公用一个数据库文件，仍有磁盘IO竞争；分库容易数据迁移不同数据库实例，扩展好）（线性提升数据库写能力，降低单库容量）-垂直切分（降低单库容量，降低磁盘IO，跟业务紧密相关）

使用spring-session 和 redis 实现 session集群共享

for循环改写 for(int i = 0; int temp = xxx.size();i  temp;i++)
引起FULL GC原因，老年代不够用了，永久代元空间不够用了，system.gc
 

jdk动态代理是基于接口代理，而CGLIB则不是
spring 5.x 中AOP默认使用JDK动态代理

springboot 2.x默认使用CGLIB，要想使用JDK 配置项  spring.aop.proxy-target-class=false
 
除了构造注入会导致强依赖以外，一个bean也会强依赖于暴露他的配置类。不要对有@configuration注解的配置类进行field级的依赖注入

hikaricp连接池的使用，spring 事务利用AOP原理进行round的方法增强，增强方法调用内部方法时，必须通过引用XXservice.method方法调用才会是事务生效，否则不生效

幂等

1. 查询操作
2. 删除操作
3. 唯一索引，防止新增脏数据
4. token机制
防止页面重提交：
集群环境：采用token加redis；
单机环境token加jvm内存；
处理流程： 1.数据提交前服务器申请token，token放到redis或内存，设置token有效时间 2提交后验证token并删除，表示验证成功并生成新token返回；注意：select+update很容易造成并发问题。应直接采用delete操作并判断执行结果

5. 悲观锁
6. 乐观锁
	- 版本号
	- 条件限制
	- 分布式锁
	- select insert：并发不高的环境，如管理员后台等操作使用
	- 状态机：比如任务，审核流程流转等，上一个状态无法在下一个状态之后发生等
	- 对外提供接口，如付款，通过提交请求的附带 source来源，seq序列号决定唯一性
	
@cacheevict方法和@transactional事务同时用的情况下很可能导致redis刷新缓存失败，参考aop round就像一层一层的包裹与解开必然执行顺序和提交顺序会有差别，解决方案：缩小事务范围

springboot2.5.8升级时 默认Integer和date是不能互相转换，会报错，而之前版本时可以的

spring 事务利用AOP原理进行round的方法增强，增强方法调用内部方法时，必须通过引用XXservice.method方法调用才会是事务生效，否则不生效
事务传播行为：
PROPAGATION_REQUIRES_NEW：始终启动一个新事务，两个事务无关联
PROPAGATION_REQUIRED_NESTED：在原事务内启动一个内嵌事务，两个事务有关联，外部事务回滚，内部也会回滚
 
hikaricp连接池的使用，spring 事务利用AOP原理进行round的方法增强，增强方法调用内部方法时，必须通过引用XXservice.method方法调用才会是事务生效，否则不生效
 
reactive programming：响应式编程，面向数据流和变化传播的编程方式

Flux-onNext() onComplete() onError() 

mybatis和jpa的选择：
jpa


jdbctemplate jparespository,mongotemplate mongoresipository,redistemplate redisresipository,redis哨兵和集群

Reactor:一个轻量级JVM基础库，帮助你的服务或应用高效，异步地传递消息

- 高效：消息从A到B产生很少的内存垃圾 2解决消费者处理消息效率低于生产者带来的溢出问题 3尽可能提供非阻塞异步流


reactive:面向数据流和变化传播的编程范式

**为什么mysql分页会出现重复数据**

- mysql优化器在遇到order by limit语句时，使用priority queue，在不能使用索引有序性时，如果要排序并limit N时，只需在排序过程中保留N条记录即可。而5.6版本priority queue使用了堆排序。堆排序时不稳定的。

**分页是建立在排序基础上，进行数量的范围的分隔。排序是数据库提供的功能，分页却是衍生出来的应用需求**


**常见排序问题**

- 不加order by排序时，oracle查询的数据是混乱的，mysql由于聚餐索引，数据是有序的
- oracle的Null和Null值是无法比较的，既不是相等也不是不相等。对应空字符串，MySql是字符串长度为0空串，Oracle对其作为Null处理


**arthas线上诊断工具使用**

**热部署**

平常碰到一些线上bug，为了定位问题，和解决问题，需要修改源代码

- 反编译class文件：jad --source-only com.yates.project.TestService > /tmp/TestService.java
- 修改java文件：vim /tmp/TestService.java
- 查询源文件classLoader：sc -d com.yates.project.TestService | grep classLoaderHash
- 编译源文件：mc -c asd2ff1 /tmp/TestService.java -d /tmp
- 热更新：redefine /tmp/SchedulingTaskController.class

注意：很多时候使用MC编译时会报错，所以建议使用还能Idea编译后再使用redefine更新class文件

arthas其他指令：

- dashboard：查看线程情况，内存使用情况
- thread：当前线程信息，查看线程的堆栈
- jvm：查看jvm情况
- vmoption：查看jvm配置参数
- logger:查看日志配置 logger --name ROOT --level DEBUG:更新日志级别
- heapdump：dump堆栈信息
- monitor：查看某个方法的调用情况,调用次数，成功次数，RT
- watch：方法执行情况，入参，返回值，异常
- trace：方法链路追踪，性能开销，调用链路
- tt:记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测

**Class.forName和Classloader区别**
前者会自动初始化类（JDBC），后者不会（Spring Ioc），


**BeanUtils的坑**
工具用不好，就是坑自己。
1.Spring的BeanUtils的CopyProperties方法需要对应属性有get和set方法
2.


**可执行jar包**
Jar描述，META-INF/MAINFEST.MF 描述main-class：JarLauncher  执行 start-class
Spring Boot Loader 
项目内容
项目依赖

配置HTTP2需要java9，tomcat9 以上版本，配置SSL，配置属性项 server.http2.enabled。
HTTP库中OkHttp支持HTTP2，RestTemplate配置 OkHttp3ClientHTTPRequestFactory

web容器配置也可以通过springboot属性配置，编程方式也可以实现

**12-Factor-App**
基准代码：一份基准代码，多份部署
依赖：显示声明依赖关系
配置：环境中存储配置
后端服务：把后端服务当做资源
构建，发布，运行：严格分离构建与运行
进程：以一个或多个无状态进程运行应用
端口绑定：通过端口绑定提供服务
并发：通过进程模型进行扩展
易处理：快速启动和优雅终止可最大化健壮性
开发环境与线上环境等价：尽可能保持开发，预发布，线上环境相同
日志：把日志当做事件流
管理进程：后台管理任务当做一次性进程运行


Eureka，zookeepeer，consul，nacos都可作为服务注册中心
@EnableEurekaServer  允许作为服务注册
@EnableFeignClients  允许使用feign调用服务，

@LoadBalanced

@EnableEurekaClient  允许服务发现，调用

@EnableCircuitBreaker 允许发生服务熔断

feign.hystrix.enabled=true Feign支持服务熔断

@EnableHystrixDashboard观察熔断情况

@HystrixCommand(fallbackMethod = "fallback") 客户顿调用服务发生熔断机制
* 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
* 请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。
* 错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。

hystrix停止维护
resilience4j，一款轻量级抑郁使用容错库，可以提供熔断，限流的功能

spring cloud stream：一款构建消息驱动的微服务应用轻量级框架，发布订阅，消费组，分区；声明式编程；支持mq，kafka等中间件。
通过与Binder直接打交道，应用生产者，消费者与消费系统之间桥梁

spring cloud Sleuth：服务链路治理：
zipkin 支持web和mq

服务治理：架构设计是否合理，哪些链路时关键链路，链路容量水位趋势，系统变更管理和审计，微观上，系统依赖了什么，有哪些配置，主观与客观质量
