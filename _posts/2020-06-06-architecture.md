---
layout: post
title: '架构之路'
subtitle: '架构之路-理论知识'
date: 2020-06-06
categories: 架构
author: yates
cover: 'http://cctv.com'
tags: 架构
---

## 前言

### **架构发展历史**

- 机器语言对于开发人员来说，**太难写，太难读，太难改**
- 汇编语言需要**精通计算机底层知识**，而且**不同CPU的汇编指令**和结构是不同的	
- 高级语言无法应对**软件规模和复杂化**
- 软件工程，结构化程序 整体上降低软件开发难度，缓解了软件危机。
- 面向对象 缓解了业务变化带来的软件扩展难度

架构历史发展中 没有 放之四海而皆准的银弹

**架构设计的目的是为了解决软件系统复杂度带来的问题 **

## **系统，模块，组件，架构**

**系统**

- 关联：系统由一群有关联个体组成。（如：发动机和轮胎，底盘，而不是和PC）
- 规则：系统个体需按照指定规则运作。而不是个体各自为政
- 能力：系统能力和个体能力有本质差别，系统能力不是个体能力之和，而是产生新能力

**子系统**

由一群关联个体所组成系统，多半是更大系统中一部分

**模块和组件**

从逻辑角度拆分系统，得到单元是“模块”，主要目的是**职责分离**；从物理角度拆分系统后，得到单元是“组件”,主要目的是**单元复用**。

**架构**

指软件系统的顶层结构，架构需要明确系统需要包含哪些个体（子系统，模块，组件）


## **复杂度来源**

### **高性能**

**单机复杂度**

单机高性能软件中，需要考虑多进程，多线程，并发，通信等众多技术点

**集群复杂度**

单机的性能最终有上限的，一个复杂系统运行单机上，所需要关注的性能点很多，相互影响，当性能问题产生时，不好定位，不好作出调整，需要考虑通过集群的**任务分配，任务分解**来达到性能目标。简单的系统更容易做到高性能，单任务也更容易进行扩展

### **高可用**

系统高可用方案五花八门，本质上都是通过“冗余”来实现，通常高可用场景为**计算高可用，存储高可用**，通过**独裁，协商，民主等状态决策方式**得到决策方案。状态决策不可能万无一失，但不做高可用方案又会产生更大问题

### **可扩展**

通过**预测变化和应对变化**的方式在软件开发中缓解可扩展的问题，后者通过系统拆分**变化层和稳定层**，设计变化层和稳定层之间的接口，**抽象和实现**的隔离等方法来应对

### **低成本，安全，规模**

- 低成本本质和高性能和高可用是冲突的，比如服务器资源问题；在很多时候低成本不会是架构设计首要目标，而是架构设计附加约束。我们有一个设计方案，是否满足成本目标，如若不能，则要重新设计，甚至需要创新（引入，自研新技术）。
- 安全，**功能安全**通常更编码有关，往往是在问题出现后进行补救，无法预测下一个漏洞在哪儿，而**架构安全**主要依赖防火墙，同样设计到成本问题
- 规模，功能，数据的增多带来系统复杂度的增长和质变，前者**功能数量和功能之间连接数量**降低整个系统完全可用率；后者需要对数据进行拆分，存储方式上处理


## **架构设计三原则**

### **合适**

**合适优于业界领先**，真正优秀的架构是在企业当前**人力，条件，业务等约束**下设计出来的，能够合理将**资源整合**到一起发挥**最大功效，并快速落地**

### **简单**

复杂在制造领域代表先进，软件领域确代表问题。不管是**结构**还是**逻辑**带来的**复杂性**都无法拥抱**软件的变化本质**

### **演进**

架构设计不可贪大求全，盲目照搬大公司做法，应认真分析当前业务特点，明确面临问题，合理设计，快速落地满足业务需求，运行过程不断完善架构，不断随业务演化架构


## **架构设计流程**

- **识别复杂度**：将主要的复杂度问题列出来，根据业务，技术，团队综合情况进行排序，优先解决当前面临最主要复杂度问题
- **设计备选方案**：架构师需要设计多个备选方案，3~5个最佳；备选方案差异要比较明显；备选方案要不限于已熟悉技术；关注技术选型而不是技术细节
- **评估和选择备选方案**：列出我们需要关注的质量属性点（性能，可用性，硬件成本，项目投入，复杂度，安全性，可扩展性），分别从质量属性维度评估每个方案，再综合挑选适合当时情况最优方案。综合当前业务发展情况，团队人员规模和技能，业务发展预测等优先级进行选择
- **详细方案设计**：将方案涉及的关键技术点确定下来，同时备选方案的技术关键细节有较深入的理解。而不是只是个PPT架构师


## **高性能数据库**

### **读写分离**

通过对数据库服务器搭建集群，一主多从结构。需要注意，主备延迟和分配机制的问题

### **分库分表**

按照业务模块将数据分散到不同数据库服务器，百万，千万用户规模，需要注意，join操作问题，事务问题，成本问题，
亿级用户时，单表的性能无法支撑功能的正常运行，通过垂直和水平切分的手段进行。需要注意，路由问题（范围，Hash，配置路由），join操作，count操作问题，order by问题

### **Nosql**

关系型数据库的有很多不足：

- 只能存储行记录，无法存储数据结构
- schema扩展很不方便
- 大数据统计等场景下，由于需要读出所有记录到内存，所需I/O很高
- 全文搜索功能比较弱

Key-Value结构的Redis，主要缺点不支持完整ACID事务，
文档数据库Mongodb在新增字段简单，历史数据不会出错，很容易存储复杂数据。缺点是不支持事务，无法实现join操作
列式数据库按照列式存储数据，业务同时完成一行中多个列的读取，写操作，需要有特定的使用场景
全文搜索引擎，通过倒排索引的技术，建立单词到文档的索引，达到通过关键词查询文档内容 

## **缓存**

缓存穿透，缓存击穿，缓存雪崩等问题

## **单服务 PPC与TPC**

单服务器高性能关键之一就是服务器采用的并发模型，设计两点：

- 服务器如何管理连接
- 服务器如何处理请求

### **PPC**

每次新连接**新建一个进程**进行处理连接请求

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/27.jpg)

- 父进程接受连接
- 父进程fork子进程
- 子进程处理连接读写请求

虽然父进程fork子进程后，直接close，但是**真正关闭连接是等子进程调用close后**

PPC模式适用于服务连接数没那么多情况，对于成千上万并发量的**缺点**：

- 1fork代价高；
- 2父子进程通信复杂；
- 3支持并发连接数有限


### **prefork**

提前创建进程，当连接进来时，省去fork进程的操作

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/28.jpg)

多个子进程accept同一个socket，但一个连接只保证只有一个进程能accept成功。


### **TPC**

每次新连接新建一个线程进行处理连接请求

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/29.jpg)

缺点：解决了fork代价高和进程通信复杂，

- 每秒上W连接请求还是会有性能问题
- 引入了共享变量同步问题，可能会导致死锁
- 多线程相互影响，某线程异常导致整个进程退出

### **prethread**

提前创建线程，当连接进来时，省去fork进程的操作

常见实现方式：

- 主进程accept，将连接交给某线程处理
- 子线程尝试accept，最终一个线程accept成功

有些服务器会尝试创建多个进程，每个进程创建多个线程。避免了某线程异常导致进程退出，其他进程继续提供服务

### **Reactor**

PPC模式 如果一个进程处理多个连接时，若当前连接无数据可读，进程阻塞read操作，其他连接则会无法处理。

- 非阻塞模式：将read操作改为非阻塞，进程不断轮询多个连接。但轮询消耗CPU，特别是成千上万连接
- 多路复用：多条连接共用一个阻塞对象，进程只需一个阻塞对象等待；2当某连接有数据可处理时，操作系统通知进程，进程从阻塞状态返回，开始业务处理

Reactor模式包括Reactor和处理资源池，Reactor负责监听和分配事件，资源池负责处理事件。

典型实现方案：

**单Reactor单进程/线程**

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/30.jpg)

- Reactor通过select监控连接事件，并通过dispatch进行分发
- 若是连接建立事件，则由Acceptor处理，Acceptor通过accept接受连接，创建handler处理连接后续的事件
- 若不是连接建立事件，调用对应Handler进行响应
- Handler完成read-业务处理-send整个业务流程

缺点：

- 无法发挥多核CPU性能
- Handler处理某个连接，该进程无法处理其他连接事件

Redis使用该模式

**单Reactor多线程**

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/31.jpg)

- 主线程，Reactor通过select监控连接，然后dispatch进行分发
- 连接建立事件由accepter进行处理，并创建handler处理后续事件
- 若不是连接建立事件，调用对应Handler进行响应
- Handler只响应，read数据后，发给Processor进行业务处理
- Processor在独立子线程完成真正业务处理，然后将结果发给主进程Handler处理，Handler通过send发送结果到client

缺点：

- 多线程共享数据同步问题
- Reactor承担所有事件监听，响应，瞬间高并发会成为瓶颈


**多Reactor多进程/线程**

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/32.jpg)

- 父进程mainReactor通过select监控连接事件，并通过Acceptor接收，将新连接分配到子进程
- 子进程subReactor将连接加入连接队列进行监听，创建Handler处理连接后的事件
- 新事件导致subReactor调用handler进行处理
- handler完成--read--业务处理--send业务流程


### **Proactor**

Reactor是非阻塞同步模型，而Proactor是异步模型


![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/33.jpg)

异步I/O能充分利用DMA特性，让I/O操作与计算重叠



## **负载均衡**

### **DNS负载均衡**

通过地理区域进行流量负载，就近访问。提升访问速度

缺点：

- DNS缓存，更新不及时
- 扩展性差，控制权在域名服务商，无法对其做定制化，扩展
- 分配策略简单，无法感知后端服务器状态

### **硬件负载均衡**

功能强大，性能强大，稳定性高，安全防护，唯一缺点就是贵，一台F5顶一台马6,Q7

### **软件负载均衡**

万级别请求处理性能，最高几十万级别，硬件则是百万级别

一般的异地多活系统部署，请求访问会先进行**地理级别DNS负载，然后是集群级别硬件负载，然后才是机器级别的软件负载**


### **算法**

**轮询**

算法简单，无需关注服务器本身状态

**加权轮询**

根据硬件配置进行轮询

**负载最低优先**

根据不同负载指标：连接数，HTTP请求数，CPU负载，I/O负载指标进行服务器状态感知。

缺点：复杂度上升，本身可能成为性能瓶颈


**性能最优类**

站在client的角度，通过一定**周期**内的**响应时间**进行采用统计等方式

缺点：不管是全统计还是采样，对于周期的判断要进行不断测试调优

**Hash**

将同IP或ID进行hash，适用于存在业务，会话的场景


## **CAP**

分布式系统，涉及读写操作时，只能保证consistency,available,partition tolerance三者中两个，另外一个必须被牺牲

**consistency**

对某个指定客户端来说，读操作保证返回最新写操作结果

**available**

非故障节点合理时间返回合理响应（非错误/超时响应）

**partition tolerance**

出现网络分区时，系统能够继续**履行职责**

应该根据系统内不同数据按照**不同的业务场景和要求进行分类**，选择**合适的CAP取舍**，而不是整个系统都是同一个策略

**ACID是数据库事务完整性理论，CAP是分布式系统设计理论，BASE是CAP中AP理论的延伸**

## **FMEA**

**故障模式和影响分析**

分析方法：

- 给出初始架构设计图
- 假设架构中某个部件发送故障
- 分析故障对系统功能造成影响
- 根据分析结果，判断架构是否需优化

FMEA分析表

- 功能点：从用户角度的功能点，登录，注册等，而不是数据库存储功能等
- 故障模式：故障产生现象。描述要精确，尽量量化。mysql不可用3分钟
- 故障影响：故障产生，具体功能点受到什么影响。描述要精确，尽量量化
- 严重程度：根据不同的业务，故障影响有不同的评价标准，致命/高/中/低/无
- 故障原因：相同故障现象可能由不同故障原因产生，需要不同检测手段，不同处理措施
- 故障概率：某个故障原因发送概率。高/中/低
- 风险程度：严重程度 * 故障概率
- 已有措施：某个故障原因的处理措施
- 规避措施：降低故障概率的 技术/管理手段
- 解决措施：解决故障的 技术/管理手段
- 后续规划：目前故障缺乏的措施，不足，通过风险程度进行评估，进行后续改进


## **高可用存储**

### **主备**

主备模式，备机只做**备份**，双方只进行数据复制，主备切换需要人工操作

### **主从**

主备模式，从机多只负责**读操作**，客户端需感知主从，不同操作发给不同机器，主机故障，读业务还可继续运行，主从延迟过大，会出现过期读问题





 
## **高可用计算**

高可用架构设计基本都是通过增加更多服务器来支持。计算高可用关键点：任务管理

### **任务管理**

- 哪些服务器可以执行任务：每个服务器都可以还是特定服务器可以
- 任务如何重新执行：1-执行失败不作处理，继续其他任务。2-任务执行完向任务管理器做ACK应答

### **主备**

主机执行计算任务，主机故障，系统不可用，主机若恢复，任务分配器继续分发任务到主机；主机若不能恢复，需人工备机升主机。（冷备，温备）

### **主从**

任务分配器根据分类分配任务到主机，从机。和主备区别时从机也执行任务，主机故障，任务管理器继续发送到主机，不管是否成功。主机支持自动恢复。不能恢复还是需要人工操作从升主

### **集群**

为了使系统自动完成切换操作，我们采用集群方式

**对称集群**

也称负载均衡集群

- 正常情况，采用轮询，随机策略分配任务到不同服务器
- 某台服务器故障（心跳检测等手段），任务分配器分发其他任务到其他服务器
- 故障恢复，任务分配器重新分配任务到该服务器

**非对称集群**

不同服务器角色不同，执行任务类型不同

- 选举Master节点
- 分配不同任务到不同服务器
- Master服务器故障，重新分配角色。Slave服务器故障，只需将故障服务器从集群剔除


## **异地多活**

采用多种手段，保证**大部分用户核心业务异地多活**


地理位置不同系统提供业务服务，某地方业务异常，通过人工干预，将备机变活，用户能访问其他地方正常业务系统。但是系统复杂度提升，成本会上升

- 同城异区：设计，实现成本低，几乎一样的网络传输速度。无法抗地区灾害
- 跨城异地：网络传输速度降低，抗风险能力强，会带来数据不一致问题，对应支付相关强一致性数据等业务，无法做到
- 跨国异地：同样有延迟的缺点，主要场景为不同地区用户提供服务，只读类业务才做多活

**跨城异地技巧**

- 保证核心业务：区分真正对用户影响最大的业务进行多活，如登录
- 保证数据最终一致性：
- 采用多种手段同步数据：消息队列（账号信息），二次读取（本地无法读取，从对端获取），存储系统同步（密码），回源读取方式（session），重新生成数据方式（登录）
- 只保证绝大多数用户异地多活：物理规律决定了无法100%业务可用，对于强一致性业务，如转账，通过申请，同步成功才可转账成功
- 挂公告，事后补偿，补充体验

**跨城异地设计步骤**

- 业务分级：通过将访问量大，核心业务，产生大量收入的业务挑选出来，为其设计异地多活
- 数据分类：对挑选核心业务数据进行分析，识别数据特征，如：数据量，唯一性，实时性，可丢失性，可恢复性
- 数据同步：确定数据特定后，根据不同数据设计不同同步方案。如：存储系统同步，消息队列同步，重复生成
- 异常处理：同步数据方案始终是有缺陷的，出现异常时，导致同步延迟，数据丢失，不一致情况时处理方式。如：多通道同步，同步和访问结合（优先本地数据，再通过路由规则跨机房异地访问数据）
- 日志记录：用于故障恢复时，对用户数据进行恢复，本地，异地，服务器，数据库都可保持数据

## **接口故障处理**

接口故障常由于系统压力大，负载高等引发其他后续问题

- 内部原因：bug导致死循环，耗尽内存，CPU等资源
- 外部原因：外部攻击，抢购活动，三方大量系统请求，三方系统响应缓慢

**处理方案**

- 降级：提供部分功能，丢车保帅
- 熔断：通过API调用层进行采样，统计设定一定阈值进行接口禁用
- 限流：
    - 基于请求限流：从用户访问压力角度考虑应对故障，控制外部请求总量，时间限制量。
    - 基于资源限流：对连接数，文件句柄，线程数等内部资源按照系统压力阈值进行设置
- 排队：限流的变种

## **可扩展架构**

可扩展和高可用一样设计方法很多，但总结一个字**“拆”**

**常见拆分思路**

- 面向流程：业务流程每一阶段为一部分。分层结构
- 面向服务：每个服务一部分。SOA,微服务
- 面向功能：每个功能一部分。微内核架构

不同拆分方式，本质上决定系统扩展方式

分层结构的约束，强制将分层依赖限定为两两依赖，降低整体系统复杂度。代价就是冗余。不管业务多简单，每层都需处理

SOA需要依靠ESB实现各系统间的协议切换，数据转换，透明动态路由，引入了复杂性。用于整合多个系统

**SOA与微服务**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/architecture/1.png)


**微服务注意事项**

1. 服务划分过细，服务间关系复杂。单个服务复杂度下降，整体系统复杂度提高
2. 服务数量多，团队效率下降
3. 调用链太长，性能下降，问题定位困难
4. 没有自动化支撑，无法快速交付
5. 没有服务治理，管理混乱


**微服务经典实践**

1. 服务粒度：开发，设计阶段，三个人负责一个微服务；维护阶段，一个人可维护多个微服务
2. 基于业务逻辑拆分：从业务逻辑上粗粒度，细粒度都可，如：商品，交易，用户或订单，支付，物流，卖家，买家。从三个火枪手，确定合适的拆分粒度，避免过度拆分
3. 基于可扩展：对系统中业务模块进行**稳定性**排序。稳定的粒度可粗一些，不稳定粒度可细一些
4. 基于可靠性：对系统中业务模块进行**可靠性**排序，重点保证核心服务的高可用
5. 基于性能拆分：将性能要求高和性能压力大模块拆分出来


**微服务基础服务**

- 自动化测试：单元测试，单个系统级集成测试，系统间接口测试
- 自动化部署：版本管理，资源管理，部署操作，回退操作
- 配置中心：动态生效
- 接口框架：HTTP/RPC，风格，数据格式
- API网关：负责外部系统访问操作，鉴权，传输加密，请求路由，流量控制，数据过滤等功能
- 服务发现：负责发现服务并调用，分为自理式和代理式
- 服务路由：涉及路由算法，随机，轮询，最小压力，最小连接
- 服务容错：某个为负故障后的处理。包括请求重试，流控和服务隔离。和服务发现，路由一个系统中
- 服务监控：实时搜集信息分析，减少处理时间；并获得预警，降低问题影响范围和时间
- 服务跟踪：跟踪某个请求在微服务中完整路径
- 服务安全：接入安全，数据安全，传输安全，通过在配置中心配置策略供各个微服务调用

## **微内核**

面向功能进行拆分，也被称为插件化架构。

- 插件管理：可用插件，如何加载，何时加载
- 插件连接，插件如何连接核心系统，连接机制如，OSGI，消息，DI，HTTP
- 插件通信：插件键通信

**OSGI逻辑架构图**
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/architecture/2.png)

- Module：实现插件管理功能，插件称为Bundle（一个Java jar包），MANIFEST.MF元数据描述文件
- Lifecycle：实现插件连接，提供执行模块管理，Module对OSGI框架访问。定义Module生命周期操作
- Service：实现插件通信，OSGI提供服务注册，将自己注册到OSGI注册中心，并获取其他服务


## **技术演进**

企业业务可分为两类，产品类，服务类，前者技术创新推动业务如：iPhone，AlphaGO；发展；后者业务发展推动技术发展如：TB，微信

不同时期的技术演进需要根据业务复杂性（初创，发展，堆功能，优化期，架构期，竞争期，成熟期，平台，服务化），用户规模（性能，可用性）等考虑

**互联网公司大部分技术点**
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/architecture/3.png) 

- SQL：依赖关系型数据库，涉及数据库拆分，读写分离，分表，灾备等问题
- NOSQL：复杂的数据结构，性能优异，资源利用率提升
- 小文件存储：图片等文件存储HBase，Hadoop，TFS,JFS等
- 大文件存储：视频，海量日志等大量数据

## **架构重构**

**有的放矢**

架构重构要有的放矢，通常架构不满足业务时，系统各种问题频发，架构重构分析，导出都是问题，需要从纷繁复杂问题中识别**真正需要架构重构解决的问题，集中力量快速解决**。

如：后台管理系统重构，解决不合理的耦合，单点等问题，开发效率等问题

**合纵连横**

- 架构重构时大动作，持续时间长，会占用研发资源，开发和测试，要真正推动一个架构重构项目启动，需要花费大量精力游说和沟通。利益相关方沟通好，对重构达成一致共识，避免不必要反复，争执。
- 通过换位思考，合作双赢，关注长期

**运筹帷幄**

- 区分问题优先级
- 问题分类
- 确立实施难度

先救火，后优化，再重构的分段实施做法


## **开源项目选择**

1. 是否满足业务，如：1000TPS需求，不应选择难度更大的，但性能更好的技术。遵循合适原则和演化原则
2. 技术是否成熟，从版本号，使用公司数量，社区活跃度
3. 运维能力，不应只聚焦于性能，可用性，功能等指标。还应考虑，日志是否齐全，是否有命令行，管理控制台等维护工具，是否有故障检测和恢复能力。

**开源项目使用**

1. 深入研究，仔细测试。通过阅读设计文档，白皮书，核对每个配置项作用，多种场景性能测试，压力测试，观察指标，故障测试
2. 小心应用，灰度发布。先应用非核心业务，有经验后慢慢扩展
3. 做好应急，以防万一。对应重要数据和业务的功能使用开源技术时，要有成熟的方案做备份





