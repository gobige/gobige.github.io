---
layout: post
title: '架构之路'
subtitle: '架构之路-理论知识'
date: 2020-06-06
categories: 架构
author: yates
cover: 'http://cctv.com'
tags: 架构
---

## 前言

### **架构发展历史**

- 机器语言对于开发人员来说，**太难写，太难读，太难改**
- 汇编语言需要**精通计算机底层知识**，而且**不同CPU的汇编指令**和结构是不同的	
- 高级语言无法应对**软件规模和复杂化**
- 软件工程，结构化程序 整体上降低软件开发难度，缓解了软件危机。
- 面向对象 缓解了业务变化带来的软件扩展难度

架构历史发展中 没有 放之四海而皆准的银弹

**架构设计的目的是为了解决软件系统复杂度带来的问题 **

## **系统，模块，组件，架构**

**系统**

- 关联：系统由一群有关联个体组成。（如：发动机和轮胎，底盘，而不是和PC）
- 规则：系统个体需按照指定规则运作。而不是个体各自为政
- 能力：系统能力和个体能力有本质差别，系统能力不是个体能力之和，而是产生新能力

**子系统**

由一群关联个体所组成系统，多半是更大系统中一部分

**模块和组件**

从逻辑角度拆分系统，得到单元是“模块”，主要目的是**职责分离**；从物理角度拆分系统后，得到单元是“组件”,主要目的是**单元复用**。

**架构**

指软件系统的顶层结构，架构需要明确系统需要包含哪些个体（子系统，模块，组件）


## **复杂度来源**

### **高性能**

**单机复杂度**

单机高性能软件中，需要考虑多进程，多线程，并发，通信等众多技术点

**集群复杂度**

单机的性能最终有上限的，一个复杂系统运行单机上，所需要关注的性能点很多，相互影响，当性能问题产生时，不好定位，不好作出调整，需要考虑通过集群的**任务分配，任务分解**来达到性能目标。简单的系统更容易做到高性能，单任务也更容易进行扩展

### **高可用**

系统高可用方案五花八门，本质上都是通过“冗余”来实现，通常高可用场景为**计算高可用，存储高可用**，通过**独裁，协商，民主等状态决策方式**得到决策方案。状态决策不可能万无一失，但不做高可用方案又会产生更大问题

### **可扩展**

通过**预测变化和应对变化**的方式在软件开发中缓解可扩展的问题，后者通过系统拆分**变化层和稳定层**，设计变化层和稳定层之间的接口，**抽象和实现**的隔离等方法来应对

### **低成本，安全，规模**

- 低成本本质和高性能和高可用是冲突的，比如服务器资源问题；在很多时候低成本不会是架构设计首要目标，而是架构设计附加约束。我们有一个设计方案，是否满足成本目标，如若不能，则要重新设计，甚至需要创新（引入，自研新技术）。
- 安全，**功能安全**通常更编码有关，往往是在问题出现后进行补救，无法预测下一个漏洞在哪儿，而**架构安全**主要依赖防火墙，同样设计到成本问题
- 规模，功能，数据的增多带来系统复杂度的增长和质变，前者**功能数量和功能之间连接数量**降低整个系统完全可用率；后者需要对数据进行拆分，存储方式上处理


## **架构设计三原则**

### **合适**

**合适优于业界领先**，真正优秀的架构是在企业当前**人力，条件，业务等约束**下设计出来的，能够合理将**资源整合**到一起发挥**最大功效，并快速落地**

### **简单**

复杂在制造领域代表先进，软件领域确代表问题。不管是**结构**还是**逻辑**带来的**复杂性**都无法拥抱**软件的变化本质**

### **演进**

架构设计不可贪大求全，盲目照搬大公司做法，应认真分析当前业务特点，明确面临问题，合理设计，快速落地满足业务需求，运行过程不断完善架构，不断随业务演化架构


## **架构设计流程**

- **识别复杂度**：将主要的复杂度问题列出来，根据业务，技术，团队综合情况进行排序，优先解决当前面临最主要复杂度问题
- **设计备选方案**：架构师需要设计多个备选方案，3~5个最佳；备选方案差异要比较明显；备选方案要不限于已熟悉技术；关注技术选型而不是技术细节
- **评估和选择备选方案**：列出我们需要关注的质量属性点（性能，可用性，硬件成本，项目投入，复杂度，安全性，可扩展性），分别从质量属性维度评估每个方案，再综合挑选适合当时情况最优方案。综合当前业务发展情况，团队人员规模和技能，业务发展预测等优先级进行选择
- **详细方案设计**：将方案涉及的关键技术点确定下来，同时备选方案的技术关键细节有较深入的理解。而不是只是个PPT架构师


## **高性能数据库**

### **读写分离**

通过对数据库服务器搭建集群，一主多从结构。需要注意，主备延迟和分配机制的问题

### **分库分表**

按照业务模块将数据分散到不同数据库服务器，百万，千万用户规模，需要注意，join操作问题，事务问题，成本问题，
亿级用户时，单表的性能无法支撑功能的正常运行，通过垂直和水平切分的手段进行。需要注意，路由问题（范围，Hash，配置路由），join操作，count操作问题，order by问题

### **Nosql**

关系型数据库的有很多不足：

- 只能存储行记录，无法存储数据结构
- schema扩展很不方便
- 大数据统计等场景下，由于需要读出所有记录到内存，所需I/O很高
- 全文搜索功能比较弱

Key-Value结构的Redis，主要缺点不支持完整ACID事务，
文档数据库Mongodb在新增字段简单，历史数据不会出错，很容易存储复杂数据。缺点是不支持事务，无法实现join操作
列式数据库按照列式存储数据，业务同时完成一行中多个列的读取，写操作，需要有特定的使用场景
全文搜索引擎，通过倒排索引的技术，建立单词到文档的索引，达到通过关键词查询文档内容 

## **缓存**

缓存穿透，缓存击穿，缓存雪崩等问题

## **单服务 PPC与TPC**

单服务器高性能关键之一就是服务器采用的并发模型，设计两点：

- 服务器如何管理连接
- 服务器如何处理请求

### **PPC**

每次新连接**新建一个进程**进行处理连接请求

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/27.jpg)

- 父进程接受连接
- 父进程fork子进程
- 子进程处理连接读写请求

虽然父进程fork子进程后，直接close，但是**真正关闭连接是等子进程调用close后**

PPC模式适用于服务连接数没那么多情况，对于成千上万并发量的**缺点**：

- 1fork代价高；
- 2父子进程通信复杂；
- 3支持并发连接数有限


### **prefork**

提前创建进程，当连接进来时，省去fork进程的操作

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/28.jpg)

多个子进程accept同一个socket，但一个连接只保证只有一个进程能accept成功。


### **TPC**

每次新连接新建一个线程进行处理连接请求

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/29.jpg)

缺点：解决了fork代价高和进程通信复杂，

- 每秒上W连接请求还是会有性能问题
- 引入了共享变量同步问题，可能会导致死锁
- 多线程相互影响，某线程异常导致整个进程退出

### **prethread**

提前创建线程，当连接进来时，省去fork进程的操作

常见实现方式：

- 主进程accept，将连接交给某线程处理
- 子线程尝试accept，最终一个线程accept成功

有些服务器会尝试创建多个进程，每个进程创建多个线程。避免了某线程异常导致进程退出，其他进程继续提供服务

### **Reactor**

PPC模式 如果一个进程处理多个连接时，若当前连接无数据可读，进程阻塞read操作，其他连接则会无法处理。

- 非阻塞模式：将read操作改为非阻塞，进程不断轮询多个连接。但轮询消耗CPU，特别是成千上万连接
- 多路复用：多条连接共用一个阻塞对象，进程只需一个阻塞对象等待；2当某连接有数据可处理时，操作系统通知进程，进程从阻塞状态返回，开始业务处理

Reactor模式包括Reactor和处理资源池，Reactor负责监听和分配事件，资源池负责处理事件。

典型实现方案：

**单Reactor单进程/线程**

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/30.jpg)

- Reactor通过select监控连接事件，并通过dispatch进行分发
- 若是连接建立事件，则由Acceptor处理，Acceptor通过accept接受连接，创建handler处理连接后续的事件
- 若不是连接建立事件，调用对应Handler进行响应
- Handler完成read-业务处理-send整个业务流程

缺点：

- 无法发挥多核CPU性能
- Handler处理某个连接，该进程无法处理其他连接事件

Redis使用该模式

**单Reactor多线程**

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/31.jpg)

- 主线程，Reactor通过select监控连接，然后dispatch进行分发
- 连接建立事件由accepter进行处理，并创建handler处理后续事件
- 若不是连接建立事件，调用对应Handler进行响应
- Handler只响应，read数据后，发给Processor进行业务处理
- Processor在独立子线程完成真正业务处理，然后将结果发给主进程Handler处理，Handler通过send发送结果到client

缺点：

- 多线程共享数据同步问题
- Reactor承担所有事件监听，响应，瞬间高并发会成为瓶颈


**多Reactor多进程/线程**

![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/32.jpg)

- 父进程mainReactor通过select监控连接事件，并通过Acceptor接收，将新连接分配到子进程
- 子进程subReactor将连接加入连接队列进行监听，创建Handler处理连接后的事件
- 新事件导致subReactor调用handler进行处理
- handler完成--read--业务处理--send业务流程


### **Proactor**

Reactor是非阻塞同步模型，而Proactor是异步模型


![此处输入图片的描述](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/33.jpg)

异步I/O能充分利用DMA特性，让I/O操作与计算重叠



## **负载均衡**

### **DNS负载均衡**

通过地理区域进行流量负载，就近访问。提升访问速度

缺点：

- DNS缓存，更新不及时
- 扩展性差，控制权在域名服务商，无法对其做定制化，扩展
- 分配策略简单，无法感知后端服务器状态

### **硬件负载均衡**

功能强大，性能强大，稳定性高，安全防护，唯一缺点就是贵，一台F5顶一台马6,Q7

### **软件负载均衡**

万级别请求处理性能，最高几十万级别，硬件则是百万级别

一般的异地多活系统部署，请求访问会先进行**地理级别DNS负载，然后是集群级别硬件负载，然后才是机器级别的软件负载**


### **算法**

**轮询**

算法简单，无需关注服务器本身状态

**加权轮询**

根据硬件配置进行轮询

**负载最低优先**

根据不同负载指标：连接数，HTTP请求数，CPU负载，I/O负载指标进行服务器状态感知。

缺点：复杂度上升，本身可能成为性能瓶颈


**性能最优类**

站在client的角度，通过一定**周期**内的**响应时间**进行采用统计等方式

缺点：不管是全统计还是采样，对于周期的判断要进行不断测试调优

**Hash**

将同IP或ID进行hash，适用于存在业务，会话的场景


## **CAP**

分布式系统，涉及读写操作时，只能保证consistency,available,partition tolerance三者中两个，另外一个必须被牺牲

**consistency**

对某个指定客户端来说，读操作保证返回最新写操作结果

**available**

非故障节点合理时间返回合理响应（非错误/超时响应）

**partition tolerance**

出现网络分区时，系统能够继续**履行职责**

应该根据系统内不同数据按照**不同的业务场景和要求进行分类**，选择**合适的CAP取舍**，而不是整个系统都是同一个策略

**ACID是数据库事务完整性理论，CAP是分布式系统设计理论，BASE是CAP中AP理论的延伸**

## **FMEA**

**故障模式和影响分析**

分析方法：

- 给出初始架构设计图
- 假设架构中某个部件发送故障
- 分析故障对系统功能造成影响
- 根据分析结果，判断架构是否需优化

FMEA分析表

- 功能点：从用户角度的功能点，登录，注册等，而不是数据库存储功能等
- 故障模式：故障产生现象。描述要精确，尽量量化。mysql不可用3分钟
- 故障影响：故障产生，具体功能点受到什么影响。描述要精确，尽量量化
- 严重程度：根据不同的业务，故障影响有不同的评价标准，致命/高/中/低/无
- 故障原因：相同故障现象可能由不同故障原因产生，需要不同检测手段，不同处理措施
- 故障概率：某个故障原因发送概率。高/中/低
- 风险程度：严重程度 * 故障概率
- 已有措施：某个故障原因的处理措施
- 规避措施：降低故障概率的 技术/管理手段
- 解决措施：解决故障的 技术/管理手段
- 后续规划：目前故障缺乏的措施，不足，通过风险程度进行评估，进行后续改进


## **主备，主从，主主**

### **主备**

主备模式，备机只做**备份**，双方只进行数据复制，主备切换需要人工操作

### **主从**

主备模式，从机多只负责**读操作**，客户端需感知主从，不同操作发给不同机器，主机故障，读业务还可继续运行，主从延迟过大，会出现过期读问题











