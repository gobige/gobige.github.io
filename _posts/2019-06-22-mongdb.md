---
layout: post
title: 'mongoDB知识'
subtitle: 'mongoDB的一些概念及实践'
date: 2019-06-22 
categories: 中间件
author: yates
cover: 'www.baidu.com'
tags: 中间件
---

## 前言
MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。具有高负载，高性能的优势。MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。

## 一些概念/术语
sql术语|MongoDB术语|释义
---|---|---|
database|database|数据库
table|collection|数据库/集合
row|document|数据库记录行/文档
colunm|field|数据字段/域
index|index|索引
table joins| |表连接，mongdb不支持
primary key|primary key|主键，mongdb使用_id字段设置主键

**objectId组成**

- 前4个字节表示创建unix时间戳，格林尼治时间
- 接着3个字节时机器标识码
- 接着2个字节由进程id组成PID
- 最后3个字节随机数

## mongdb指令

**创建数据库**：use <dbname>  如果数据库不存在，则创建数据库。

**显示所有数据库**：show dbs  查看所有数据库

新建数据库只有在插入文档后才能在**show dbs**中显式

**删除数据库**：db.dropDatabase() 删除当前数据库 

**创建集合**：db.createCollection(<name>,<options>)

options 选项：

- capped（可选）如果为true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。**当该值为 true 时，必须指定 size 参数。**

- autoIndexId （可选）如为 true，自动在 _id 字段创建索引。默认为 false。
- size（可选）为固定集合指定一个最大值（以字节计） 
- max（可选）指定固定集合中包含文档的最大数量。

**显示所有集合**：show tables

**删除集合**：db.<collection>.drop() 


**插入文档**：db.<collection>.insert(<docment>) 
insert方法内支持对象和数组
(也可以使用insertOne和insertMany方法插入文档)

**更新文档**：

- db.<collection>.update(<query>,<update>,{upsert:<boolean>,multi:<boolean>,writeConcern::<document>}) 如果更新column不存在则创建

    - query:update更新条件，类似sql中where后内容
    - update:update的对象和更新操作符，类似sql中set后内容
    - upsert：可选，如果不存在update记录，是否插入内容，默认false
    - multi，可选，是否更新条件查询所有记录，默认false

- db.<collection>.save(<document>,{writeConcern:<document>}) 通过objectid进行更新，如果不加_id则会变成插入文档
    - document:文档数据
    - writeConcern：可选，抛出异常级别

**删除文档**

db.<collection>.remove(<query>,{justOne:<boolean>,writeConcern:<document>})

- query:(可选)删除的文档的条件
- justOne:（可选）如果设为true或1，则只删除一个文档
- writeConcern：（可选）异常级别

也可以是deleteOne deleteMany方法

**remove() 方法并不会真正释放空间。需要继续执行db.repairDatabase()来回收磁盘空间。**
**drop() 附带删除索引

**查询文档**

db.collection.find(query,projection)  // 通常只会返回20条数据

- query:可选，使用查询操作符
- projection:可选  返回值

pretty()格式化返回结果

**统计**
db.collection.count()

**比较符**
操作|mongdb查询条件|sql查询条件
---|---|---|
等于|db.col.find({"name":"yates"}).pretty()|where name = 'yates'
小于|db.col.find({"age":{lt:50}}).pretty()|where age < 50
小于或等于|db.col.find({"age":{lte:50}}).pretty()|where age <= 50
大于|db.col.find({"age":{gt:50}}).pretty()|where age > 50
大于或等于|db.col.find({"age":{gte:50}}).pretty()|where age >= 50
不等于	|db.col.find({"age":{ne:50}}).pretty()|where age != 50

**AND**
mongdb and 条件使用“，”隔开
db.<col>.find({"age":"12","sex":"m"})

**OR**
mongdb and 条件使用“&or”
db.<col>.find({$or:[{"age":"12"},{"sex":"m"}]})

**查询类型**

使用条件操作符 “”$type”进行collum的类型匹配

db.col.find({"title" : {$type : 'string'}})

**返回数据记录条数限制**
使用limiit()限制返回条数
db.<collection>.find().limit(<num>)

使用skip()方法来跳过指定数量的数据
db.<collection>.find().limit(<num>).skip(<num>)

**排序**
使用 sort() 方法对数据进行排序,**1为升序排列**，而**-1是用于降序排列**
db.<collection>.find().sort({age:1})


**创建索引**
使用 createIndex() 方法来创建索引

db.<collection>.createIndex(<keys>, <options>)

- Key值为你要创建的索引字段，1为升序,降序为-1

**查看索引**

 - 查看集合索引 db.<collection>.getIndex()
 - 查看集合索引大小 db.<collection>.totalIndexSize()
 - 删除集合所有索引  db.<collection>.dropIndexes()
 - 删除集合指定索引  db.<collection>.dropIndex("索引名称")
 
**利用 TTL 集合对存储的数据进行失效时间设置：经过指定的时间段后或在指定的时间点过期，MongoDB 独立线程去清除数据。类似于设置定时自动删除任务，可以清除历史记录或日志等前提条件，设置 Index 的关键字段为日期类型 new Date()**

- 非立即执行：扫描 Document 过期数据并删除是独立线程执行，默认 60s 
- 扫描一次，删除也不一定是立即删除成功。
 单字段索引，混合索引不支持。

**数据聚合**
aggregate()方法主要用于处理数据(诸如统计平均值,求和等

db.<collection>.aggregate("索引名称")

db.mycol.aggregate([{￥group : {_id : "￥by_user", num_tutorial : {￥sum : 1}}}])

表达式|描述
---|---|
￥sum|计算平均值	
￥avg|获取集合中所有文档对应值得最小值	
￥min|获取集合中所有文档对应值得最大值	
￥push|在结果文档中插入值到一个数组中	
￥addToSet|在结果文档中插入值到一个数组中，但不创建副本
￥first|根据资源文档的排序获取第一个文档数据
￥last|根据资源文档的排序获取最后一个文档数据	 
**管道**
MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理

- $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档
- $match：用于过滤数据，只输出符合条件的文档
- $limit：用来限制MongoDB聚合管道返回的文档数
- $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档
- $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值
- $group：将集合中的文档分组，可用于统计结果
- $sort：将输入文档排序后输出
- $geoNear：输出接近某一地理位置的有序文档



## mongodb特性

1. 数据结构，mongdb使用文档数据模型，不强制使用schema带来的好处是，应用程序的代码强制数据结构而不是数据库。普通sql关联查询会很复杂，而文档建模不需要关联，可以动态添减属性
2. ad hoc查询（不需要事先定义系统接收何种查询），
3. 索引，mongodb中索引使用了B-树，每个集合可以创建64个索引，每个文档对象建立一个主键，这也就是为什么mongodb不同于hbase之类nosql区别。
4. 复制，mongodb提供数据库复制特性，可复制集合在多个机器上分布式存储数据，在服务器和网络出错时，实现数据冗余存储和自动备灾；也常用于读写分离的场景
5. 加速与持久化，mongodb也和mysql一样通过日志来保证写入的可靠性
6. 伸缩，通过基于分区机制来实现水平扩展，称为分片机制。
