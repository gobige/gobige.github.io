---
layout: post
title: 'java内存模型'
subtitle: 'java内存模型'
date: 2018-03-12
categories: jvm
author: yates
cover: ''
tags: jvm
---

前言
在物理计算机中经常会出想并发的问题，并发执行若干个运算任务，更充分利用计算机处理器效能，看起来很简单，但是里面包含处理器与内存交互，线程与线程交互，读取运算数据，储存运算数据，缓存一致性等复杂问题。Java内存模型(JMM)定义程序中各个变量发访问规则，屏蔽了硬件与操作系统的内存访问差异，从而使java程序能供在各种平台达到一致的内存访问效果。

**JMM定义的变量**
JMM定义的变量包括实例字段，静态字段，构成数组对象，而局部变量，方法参数这些时线程私有的，所以不会发生线程安全问题。

**主内存和工作内存**
所有定义变量存储在主内存，每条线程都有自己的工作内存，用于拷贝主内存的数据，线程对变量的读取，赋值操作都在工作内存进行。工作内存对应物理位置应该是在CPU寄存器和CPU高速缓存中

**内存间交互操作**
数据在主内存和工作内存间的交互细节，JMM通过以下8种操作（具有原子性）完成

- lock：作用主内存，标识一条线程独占该变量
- unlock：作用主内存，把处于线程锁定变量释放出来
- read：作用主内存，把变量从主内存读取
- load：作用工作内存，把read的变量值放入工作内存副本中
- use：作用工作内存，把变量传给执行引擎，当字节码指令需要用到该变量时执行
- assign：作用工作内存，把从执行引擎收到的值赋给工作内存，当遇到给变量赋值的字节码指令时执行
- store：作用工作内存，把变量的值从工作内存传递到主内存
- write：作用主内存，把从store操作得到的值赋值给主内存中相应的变量

JMM规定了上述操作的限制
- read和load操作必须顺序执行；
- 不允许read和load，store和write操作中其中一个单独出现；
- 不允许线程丢弃最近assign操作，即变量在工作内存改变后必须同步回主内存；
- 不允许线程无assign操作把数据从工作内存刷回主内存
- 一个新变量只能在主内存中诞生，不允许工作内存中直接使用未被初始化的变量
- 一个变量同一时刻只允许一条线程对其lock，但可被同一条线程多次lock，反之unlock也要多次
- 如果变量被lock后，执行引擎使用改变量前必须重新load或assign操作
- unlock前必须lock操作
- unlock前，必须先把变量同步回主内存，即执行store和write操作

**volatile关键字**
被该关键字赋值的变量具有两种特性：
- 该变量对**所有线程可见性**。即变量值改变后，该变量会重新刷新到主内存，而其他所有拥有该变量的线程，都会重新去主内存刷新获取该变量值
- **禁止指令重排序**，cpu和jvm在不改变最终运算结果的情况下会对字节码指令进行重排序，从而提高运算的效率。通过插入内存屏障指令保证。

对于实现可见性，java还有final和synchronized可以实现

以下两条规则运算场景可以使用volitaile
- 运算结果并不依赖变量的当前值，或者确保单一线程修改该变量的值
- 变量不需要与其他状态变量共同参与不变约束

**long和double类型变量**
- long和double的非原子协定：对于这两种变量，运行虚拟机将没有被volatile修饰的64为数据读写操作划分为两次32位操作进行，因此这两种变量不用专门声明为volatile