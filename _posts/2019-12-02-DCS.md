---
layout: post
title: '分布式技术原理与算法'
subtitle: '分布式技术原理与算法'
date: 2019-12-02
categories: 分布式
author: yates
cover: 'www.baidu.com'
tags: 分布式
---


## 单机模式
所有**应用程序和数据**均部署在一台电脑或服务器上，由一台计算机完成所有的处理。存在**性能受限、存在单点失效问题**。

## 分布式模式
将**相同或相关的程序运行在多台计算机**上，从而实现特定目标的一种计算方式

### **数据并行/数据分布式**
并行计算采用**消息共享**模式使用多台计算机并行运行或执行多项任务，核心原理是每台计算机上**执行相同的程序**，将**数据拆分放到不同的计算机上**进行计算。对提升单个任务的执行性能及降低时延无效

### **任务并行/任务分布式**
将单个**复杂的任务拆分为多个子任务**，从而使得多个子任务可以在不同的计算机上并行执行。提供了更好的**性能、扩展性、可维护性**的同时，也带来了**设计复杂性**问题
 
## 分布式系统指标
性能、资源占用、可用性、可扩展性

## 分布式互斥（Distributed Mutual Exclusion）
在分布式系统里，排他性的资源访问方式，而这种被互斥访问的共享资源就叫作**临界资源**

## 分布式算法

### **集中式算法**
每个程序在需要访问临界资源时，先给**协调者**发送一个请求。如果当前没有程序使用这个资源，协调者直接**授权**请求程序访问；否则，按照**先来后到**的顺序，访问临界资源

**流程**
1. 向协调者发送**请求授权**信息，1次消息交互；
2. 协调者向程序**发放授权**信息，1次消息交互；
3. 程序使用完临界资源后，向协调者发送**释放授权**，1次消息交互。

**优点**
**直观、简单、信息交互量少、易于实现**，并且所有程序只需和协调者通信，程序之间无需通信。

**缺点**
协调者会成为系统的**性能瓶颈**，容易引发**单点故障**问题

### **分布式算法**
程序要访问临界资源时，先向系统中的**其他程序**发送一条**请求消息**，在接收到所有程序返回的**同意消息**后，才可以**访问临界资源**。其中，请求消息需要包含所请求的**资源、请求者的ID，以及发起请求的时间**。也常使用组播和逻辑时钟的算法。

**缺点**
在大型系统中使用分布式算法，**消息数量**会随着需要访问临界资源的程序数量呈**指数级增加**，容易导致高昂的**沟通成本**

### **令牌环算法**
所有**程序构成一个环结构**，**令牌**按照顺时针（或逆时针）方向在程序之间**传递**，收到令牌的程序有权**访问临界资源**，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序

**优点**
**公平性高**，在改进单点故障后，稳定性也很高，**适用于系统规模较小**，并且系统中每个程序**使用临界资源的频率高**且使用**时间比较短**的场景。


![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/13.jpg)

### **两层结构的分布式令牌环算法**
广域网由多个局域网组成，因此在该算法中，局域网是较低的层次，广域网是较高的层次。每个**局域网**中包含若干个**局部进程**和一个**协调进程**。局部进程在逻辑上组成一个环形结构，在每个环形结构上有一个**局部令牌T**在局部进程间传递。**局域网与局域网**之间通过各自的**协调进程进行通信**，这些协调进程同样组成一个环结构，这个环就是广域网中的**全局环**。在这个全局环上，有一个**全局令牌**在多个协调进程间传递。

## 主节点
在一个分布式集群中负责对其他节点的协调和管理

### **Bully算法**
活着的节点中，选取**ID最大的节点**作为主节点。

**优点**
选举**速度快、算法复杂度低、简单易实现**。

**缺点**
每个节点有**全局的节点信息**，额外信息存储较多；其次，任意一个比当前主节点ID大的新节点或节点故障后恢复加入集群的时候，都可能会触发**重新选举**，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主。

**流程**

- 集群中每个节点判断自己**是否为当前活着的节点中ID最大**的，如果是，则直接向其他节点**发送Victory**消息，宣誓自己的主权；
- 如果自己不是当前活着的节点中ID最大的，则**向比自己ID大**的所有节点**发送Election**消息，并**等待其他节点的回复**；
- 若在**给定的时间范围**内，本节点**没有收到**其他节点回复的**Alive消息**，则认为自己成为主节点，并向其他节点**发送Victory消息**，宣誓自己成为主节点；若接**收到**来自比自己ID大的节点的**Alive消息**，则**等待其他节点发送Victory消息**；
- 若本节点**收到**比自己ID小的节点发送的**Election**消息，则**回复一个Alive消息**，告知其他节点，我比你大，重新选举。

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/15.jpg)

### **Raft算法**

典型的多数派投票选举算法

**Leader**，即主节点，同一时刻只有一个Leader，负责协调和管理其他节点；
**Candidate**，即候选者，每一个节点都可以成为Candidate，节点在该角色下才可以被选为新的Leader；
**Follower**，Leader的跟随者，不可以发起选举。

- **初始化**时，所有节点均为**Follower状态**。
- **开始选主**时，所有节点的状态由**Follower转化为Candidate**，并向其他节点发送**选举请求**。
- 其他节点根据接收到的选举请求的**先后顺序**，回复是否同意成为主。这里需要注意的是，在每一轮选举中，**一个节点只能投出一张票**。
- 若发起选举请求的节点获得**超过一半的投票**，则**成为主节点**，其**状态转化为Leader**，**其他节点**的状态则由**Candidate降为Follower**。Leader节点与Follower节点之间会**定期发送心跳包**，以检测主节点是否活着。
- 当Leader节点的任期到了，即发现其他服务器开始**下一轮选主周期**时，Leader节点的状态由**Leader降级为Follower**，进入新一轮选主。

**优点**
**选举速度快、算法复杂度低、易于实现**

**缺点**
要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此**通信量大**。

该算法选举**稳定性比Bully算法好**，这是因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得**投票数过半**，才会导致**切主**

### **ZAB算法**

具有**优先级**的民主投票，尽可能保证**数据最新性**,**ID大的节点优先成为主**

- 3种角色：Leader，Follower，Observer。
- 4种状态：Looking,Leading,Following,Observing。
- 每个节点有三元组(server_Id,server_zxID,epoch)。

**选主原则**

**server_zxID最大**者成为Leader,若server_zxID相同，则**server_id最大**者成为Leader。

**优点**
性能稳定。

**缺点**
选举**时间较长**，容易出现**广播风暴**，需要知道所有节点的zxId和serverId 

## 分布式共识
在多个节点均可独自操作或记录的情况下，使得**所有节点**针对某个**状态达成一致**的过程。分布式共识包括两个关键点，获得**记账权**和**所有节点或服务器达成一致**

### **PoW算法**
以每个节点或服务器的计算能力，即**算力**，来**竞争记账权**

比特币系统设置的总量2100万个比特币，系统中的每个节点都有记账权，成功**获得记账权**的节点将**获得记账奖励**，这个奖励就来自于这个总量，这个就是比特币的来源。因为和黄金采矿原则类似，谁付出谁得到，因此记账的过程也被称形象的称为挖矿。

**工作量证明过程**
利用区块的index、前一个区块的哈希值、交易的时间戳、区块数据、nonce值，通过SHA256计算出一个**哈希值**，这里的nonce值是无法直接猜出的，所以只能大量的**穷举尝试**并且每次尝试都需要一定的计算量，因此需要大量的计算量才能得到一个**正确的nonce值**。每次为了争取一个区块的记账权，而获得正确nonce值的过程就是一个PoW（工作量证明）

### **PoS算法**
由**系统权益代替算力**来决定区块记账权，拥有的权益越大，获得记账权的概率就越大

### **DPoS算法**
是一种委托权益证明算法。持有币的人可以**通过投票选举**出一些节点，来作为代表去记账


![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/12.jpg)

## 实现分布式事务

### **XA协议的二阶段提交**
XA协议可以分两部分，即**事务管理器**和**本地资源管理器**。

- 事务管理器作为**协调者**，负责各个本地资源的提交和回滚；
- 而资源管理器就是分布式事务的**参与者**，通常由数据库实现

**执行过程**
分为**投票**（voting）和**提交**（commit）两个阶段。协调者**下发请求事务操作**，参与者将**操作结果通知协调者**，协调者根据所有参与者的**反馈结果决定**各参与者是要**提交操作还是撤销操作**

**缺点**
**同步阻塞**问题，**单点故障**问题，提交阶段由于网络问题等导致的**数据不一致**问题

### **三阶段提交**
为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了**超时机制和准备阶段**

同时在协调者和参与者中引入**超时机制**。如果协调者或参与者在规定的时间内**没有接收**到来自其他节点的**响应**，就会根据当前的状态选择**提交或者终止整个事务**。

在第一阶段和第二阶段中间引入了一个**准备阶段**，也就是在提交阶段之前，加入了一个**预提交**阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。

CanCommit、PreCommit、DoCommit三个阶段

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/3.jpg)
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/4.jpg)
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/2.jpg)

**PreCommit阶段**
协调者根据参与者的**回复情况**，来决定是否可以进行PreCommit操作。如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：

- **发送预提交请求**:协调者向参与者发送PreCommit请求，进入预提交阶段。
- **事务预提交**:参与者接收到PreCommit请求后执行事务操作，并将**Undo和Redo信息记录**到事务日志中。
- **响应反馈**:如果参与者成功执行了事务操作，则返回ACK响应，同时开始等待最终指令。
假如任何一个参与者向协调者**发送了“No”消息，或者等待超时**之后，协调者都没有收到参与者的响应，就执行**中断事务**的操作：
- **发送中断请求**:协调者向所有参与者发送“Abort”消息。
- **中断事务**:参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的中断操作。

2PC和3PC这两种方法，有两个共同的**缺点**，一是都需要**锁定资源，降低系统性能**；二是，没有解决**数据不一致**的问题。基于分布式消息的**重试机制**，得到最终一致性方案

**刚性事务**

遵循ACID原则，具有强一致性。比如，数据库事务。

**柔性事务**

其实就是根据不同的业务场景使用不同的方法实现**最终一致性**，也就是说我们可以根据业务的特性做部分取舍，容忍一定时间内的数据不一致


![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/14.jpg)

### **BASE理论**
**基本可用**：分布式系统出现故障的时候，允许**损失一部分功能的可用性**。比如，某些电商618大促的时候，会对一些非核心链路的功能进行**降级**处理。

**柔性状态**：在柔性事务中，允许系统存在**中间状态**，且这个中间状态**不会影响系统整体可用性**。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一种柔性状态。

**最终一致性**：事务在操作过程中可能会由于同步延迟等问题导致不一致，但最终状态下，数据都是一致的。


![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/5.jpg)

### **分布式锁**
与普通锁不同的是，是指分布式环境下，系统部署在多个机器中，实现**多进程分布式互斥**的一种锁

**实现方式**

- 数据库实现，缺点，单点故障，死锁
- Redis等中间件实现，setnx(key, value)函数来实现分布式锁。key和value就是基于缓存的分布式锁的两个属性，其中key表示锁id，value = currentTime + timeout，缺点，通过超时时间控制锁不靠谱（网络问题）
- zookeepeer实现，基于树形数据存储结构实现分布式锁。每个进程请求创建一个临时节点，确认是否是该树下最小子节点，若是，则获取锁，若本进程对应的临时节点编号不是最小的，则分为两种情况：

a. 本进程为读请求，如果比自己序号小的节点中有写请求，则等待；
b. 本进程为写请求，如果比自己序号小的节点中有读请求，则等待

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/11.jpg) 

在整个分布式锁的竞争过程中，大量的**“Watcher通知”和“子节点列表的获取”**操作重复运行，并且大多数节点的运行结果都是判断出自己当前并不是编号最小的节点，继续等待下一次通知，而不是执行业务逻辑，若本进程对应的临时节点编号不是最小的，则继续判断：
若本进程为读请求，则向比自己序号小的最后一个写请求节点注册watch监听，当监听到该节点释放锁后，则获取锁；
若本进程为写请求，则向比自己序号小的最后一个请求节点注册watch监听，当监听到该节点释放锁后，获取锁


## 分布式资源管理

### **分布式体系结构**

**集中式结构**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/6.jpg)

一台或多台服务器组成**中央服务器**，系统内的**所有数据都存储在中央服务器**中，系统内所有的业务也均先由中央服务器处理。多个节点服务器与中央服务器连接，并将自己的信息汇报给中央服务器，由中央服务器统一进行资源和任务调度：中央服务器根据这些信息，将任务下达给节点服务器；节点服务器执行任务，并将结果反馈给中央服务器。

Redis集群是一个**非集中式集群**管理系统，没有中心节点，不会因为某个节点造成性能瓶颈，**每个节点均支持数据存储**，且采用**分片存储**方式，提高了**写的并发**能力。同时，每个节点的设计采用**主备**设计，提高了**数据的可靠性**。

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/7.jpg)

Akka集群是一个完全去中心化的集群管理系统，节点之间都是P2P的连接模式，通过Gossip协议来进行通信，节点之间有**角色划分**，负责数据存储的节点会进行存储数据。

Redis集群也是P2P的网状连接模式，但是基于**key-value的数据库模型**，**每个节点**都可以执行**数据的计算和存储**。此外，Redis集群引入了**哈希槽**的概念，来解决数据的**分片存储**问题。

Cassandra集群的结构是**一致性哈希**的P2P，节点会构成一个**环结构**，通过哈希映射来选择对应的节点

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/8.jpg)

在主备场景下，正常情况下，主节点提供服务，备节点是对主节点的数据、状态进行备份，以确保主故障后备升主后业务可以正常运行。主备节点之间通常会通过心跳的方式进行检测，目的是监控主节点是否故障，若故障则备升主，保证业务运行，如果主备节点网络端口，两者之间心跳均不可达，就会出现**双主现象**

**集中式架构，Master判断Slave存活方式**
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/23.jpg)
上图中，TCP连接针对Slave进程退出的情况，而Slave所在器服务器故障，宕机的情况下，则使用心跳的方式进行检测。


### **单体调度**
一个集群中只有**一个节点运行调度进程**，该节点对集群中的其他节点具有**访问权限**，可以搜集其他节点的**资源信息、节点状态**等进行统一管理，同时根据用户下发的任务对资源的需求，在调度器中进行**任务与资源匹配**，然后根据匹配结果将**任务指派**给其他节点

单体调度器**拥有全局资源视图和全局任务**，可以很容易地实现对任务的约束并实施全局性的调度策略

**单体调度的特征**
- 很容易实现对作业的约束并实施**全局性的调度策略**，因此适合**批处理任务和吞吐量较大、运行时间较长**的任务。
- 单体调度系统的**状态同步**比较**容易且稳定**，这是因为资源使用和任务执行的状态被统一管理，降低了状态同步和并发控制的难度。
- 调度**算法内置在核心调度器**当中，因此调度框架的**灵活性**和策略的**可扩展性**不高。
单体调度存在**单点故障**的可能性

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/1.jpg)

### **两层调度**
资源的使用状态同时由**中央调度器**和**第二层调度器**管理，中央调度器从整体上进行**资源的管理与分配**，将资源分配到第二层调度器；再由第二层调度器负责将**资源与具体的任务配对**，因此第二层调度可以有多个调度器，以支持不同的任务类型。

**中央调度器算法**
通常有最大最小公平算法和主导资源公平算法等

- 最大最小公平算法：适用于**单一类型的资源分配**场景，从公平的角度出发，为每个用户分配不多于需求量的资源
- 主导资源公平算法：适用于**多种类型资源混合的场景**，从任务出发，尽量**充分利用资源**使得能够执行的任务越多越好。
 
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/9.jpg)

### **共享状态调度器**
通过将**单体调度器分解为多个调度器**，每个调度器都有**全局的资源状态信息**，从而实现最优的任务调度，提供了更好的**可扩展性**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/10.jpg)

### **乐观并发调度**
强调事后检测，在**事务提交时**检查是否避免了冲突：若避免，则提交；否则回滚并自动重新执行。也就是说，它是在执行**任务匹配调度算法后**，待计算出结果后再进行冲突检测。

### **悲观并发调度**
强调事前预防，在**事务执行时**检查是否会存在冲突。不存在，则继续执行；否则等待或回滚。也就是说，在执行**任务匹配调度算法前**，通过给不同的Framework发送不同的资源，以避免冲突

## 分布式计算

### **MapReduce**
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/27.jpg)

Fork-Join计算模式是Java版本的MapReduce思想实现

### **流数据Stream**
需要实时处理的数据，我们称之为流数据，适用流数据大量、快速、时变的流形式持续在应用中产生的处理数据密集型应用

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/28.jpg)
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/29.jpg)

### **Actor计算模式**
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/30.jpg)

### **流水线计算模式**
将一个大任务拆分为多个步骤执行，不同的步骤可以采用不同的进程执行

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/17.jpg)


## 分布式通信

**本地调用**：进程内函数之间的相互调用；
**远程调用**：进程间函数的相互调用

### **RPC**
调用方采用**参数传递**的方式，通过**调用本机**一个函数或方法，去**执行远程**机器上的函数或方法（可以统称为服务），并返回结果

**核心**
远程过程调用和调用一次本地服务没什么不同

**RPC与本地调用区别**

**调用ID和函数的映射**：本地调用中，进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数，函数名如指针，得到执行方法，执行指针对应的指令，而远程调用由于**不同进程地址空间**的关系，需要在通信的两台机器间，维护一个**函数与调用ID的映射表**，进程在做远程过程调用时，必须附上这个调用ID

**序列化和反序列化**：网络协议传输的内容是二进制流，无法直接传输参数的类型，需要调用方把参数先转成一个二进制流，传到被调用方后，被调用方再把二进制流转换成自己能读取的格式

**网络传输协议**：大部分RPC框架采用的是TCP协议

### **RMI**
RMI是基于对象的，充分利用了面向对象的思想去实现整个过程，其本质就是一种**基于对象的RPC实现**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/19.jpg)

不管是RPC还是RMI，大多服务调用都是同步阻塞式的，虽然也可以使用异步，但是进程较多时，进程维护通信的复杂度非常高，这是分布式计算规模增大和复杂化需求下，出现了专门的异步通信模式

### **消息发布订阅模式**
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/20.jpg)

**观察者模式和发布订阅区别**

**观察者模式**采用了**直接通信**，观察者和被观察者**通信时延低**一些，但它们的**依赖关系比较强**，不管是被观察者还是观察者逻辑或接口有更改，另外一个均会受影响。而**发布者和订阅者模式**采用**间接通信**，引入了消息中心，相对比较厚重，且**通信时延相对会高**一点，但实现了订阅者与发布者的**解耦**。


### **消息队列模式**
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/21.jpg) 


**发布订阅与消息队列区别**

- 消息队列模式中采用了具有**先进先出特征的队列**结构进行存储，而订阅发布采用了**map或数组**等方式存储。
- 发布订阅模式中，消费者需向消息中心订阅感兴趣的数据,数据到消息中心后,消息中心将数据主动**推送**给消费者；消息队列模式中，生产者发布数据到消息中心，消息队中心存储数据，消费者**拉取**数据


## 分布式数据存储和管理

### **CAP**

- **Consistency**(一致性):所有节点在**同一时刻的数据是相同**的，即更新操作执行结束并响应用户完成后，所有节点存储的数据会保持相同
- **Availability**(可用性):系统提供的**服务一直处于可用状态**，对于用户的请求可即时响应
- **Partition Tolerance**(分区容错性):在分布式系统遇到**网络分区**(网络拥塞，网卡故障，网络不可通行)的情况下，仍然可以**响应用户的请求**

CAP三个指标不能同时满足

**保CA弃P**
多见于单体架构情况，不存在网络分区问题的系统，分布式系统难免出现网络问题，不适用改策略

**保CP弃A**
多见于分布式场景需要很强的数据一致性，或者该场景可以容忍系统长时间无响应的情况

**保AP弃C**
多见于分布式场景需要很高的可用性，或者说在网络状况不太好的情况下，该场景允许数据暂时不一致

zookeeper是基于CP的，euraka是基于AP的，zokeeper有master，slave之分，如果正在选主或集群半数以上机器不可用，那么zookeeper无法保证服务的可用；而Euraka没有，采用peer to peer通信，节点彼此互相注册提高可用性。即使所有节点都挂了，也能通过本地得到缓存数据。根据两者区别来选择合适的注册中心

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/18.jpg) 

ACID中的C强调的是**事务一致性**，而CAP中的C强调的**数据一致性**

ACID中的A强调的是**原子性**，而CAP中的A强调的**可用性**

BASE理论同时牺牲一些C，和一些A得到**服务基本可用**且**数据最终一致性**


### **分布式数据存储系统**
将数据根据某种规则存储到不同的机器上，当获取指定数据时，再按照规则到存储数据的机器里获取

**数据分片技术**
数据分片技术，是指分布式存储系统按照一定的规则将数据存储到相对应的存储节点中，或者到相对应的存储节点中获取想要的数据。减少单节点的性能瓶颈问题；

**数据复制技术**
将数据进行备份，以使得多个节点存储该数据。对每个节点上存储的分片数据，采用主备方式存储，以保证数据的可靠性

**数据的格式**
数据可以被划分为三类：结构化数据、半结构化数据和非结构化数据

**数据存储系统**
分布式数据库、分布式键值系统和分布式文件系统。


![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/24.jpg) 


### **数据分布设计原则**

**数据均匀**

- 不同节点存储的数据要均匀
- 用户访问数据要做到均匀

**数据稳定**
存储节点出现故障需要移除或者扩增时，数据按照分布规则得到的结果应该尽量保持稳定，不要出现大范围的数据迁移

**节点异构性**
不同存储节点的硬件配置可能差别很大，要考虑分到的数据量、用户访问量的问题

**隔离故障域**
为了保证数据的可用和可靠性，通过备份数据到不同的故障域，比如不同机房、不同机架

**性能稳定性**
数据存储和查询的效率要有保证，不能因为节点的添加或者移除，造成存储或访问性能的严重下降

### **数据分布方法**

**哈希**
通过哈希函数，通过特定数据特征计算得到存储节点。哈希函数设置得当，可以很好地保证数据均匀性，**缺点**：就是稳定性较差。**适用于同类型节点且节点数量比较固定的场景**

**一致性哈希**
将存储节点和数据都映射到一个首尾相连的哈希环上，存储节点可以根据IP地址进行哈希，数据通常通过顺时针方向寻找的方式，来确定自己所属的存储节点，即从数据映射在环上的位置开始，顺时针方向找到的第一个存储节点。在数据存储前，对存储节点预先进行了哈希,数据存储时采用哈希方式确定存储位置.**缺点**：均匀性问题；**适用于同类型节点、节点规模会发生变化的场景**

**带有限负载的一致性哈希**
每个存储节点设置了一个存储上限值来控制存储节点添加或移除造成的数据不均匀，**适用于同类型节点、节点规模会发生变化的场景**

**带虚拟节点的一致性哈希**
根据每个节点的性能，为每个节点划分不同数量的虚拟节点，并将这些虚拟节点映射到哈希环中，然后再按照一致性哈希算法进行数据映射和存储。**缺点**：节点的维护和管理的复杂度。**适用于异构节点、节点规模会发生变化的场景**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/25.jpg)



![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/26.jpg)



容错（fault tolerance）指的是， 发生故障时，系统还能继续运行。

灾备（又称灾难恢复，disaster recovery）指的是， 发生灾难时恢复业务的能力。灾备不是为了挽救基础设置，而是为了挽救业务。

高可用不是指系统不中断（那是容错能力），而是指一旦中断能够快速恢复，即中断必须是短暂的

