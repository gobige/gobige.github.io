---
layout: post
title: '分布式技术原理与算法'
subtitle: 'rabbitmq'
date: 2019-12-02
categories: 分布式
author: yates
cover: 'www.baidu.com'
tags: 分布式
---


## 单机模式
所有**应用程序和数据**均部署在一台电脑或服务器上，由一台计算机完成所有的处理。存在**性能受限、存在单点失效问题**。
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/dcs/1.jpg)

## 分布式模式
将**相同或相关的程序运行在多台计算机**上，从而实现特定目标的一种计算方式

### **数据并行/数据分布式**
并行计算采用**消息共享**模式使用多台计算机并行运行或执行多项任务，核心原理是每台计算机上**执行相同的程序**，将**数据拆分放到不同的计算机上**进行计算。对提升单个任务的执行性能及降低时延无效

### **任务并行/任务分布式**
将单个**复杂的任务拆分为多个子任务**，从而使得多个子任务可以在不同的计算机上并行执行。提供了更好的**性能、扩展性、可维护性**的同时，也带来了**设计复杂性**问题
 
## 分布式系统指标
性能、资源占用、可用性、可扩展性

## 分布式互斥（Distributed Mutual Exclusion）
在分布式系统里，排他性的资源访问方式，而这种被互斥访问的共享资源就叫作**临界资源**

## 分布式算法

### **集中式算法**
每个程序在需要访问临界资源时，先给**协调者**发送一个请求。如果当前没有程序使用这个资源，协调者直接**授权**请求程序访问；否则，按照**先来后到**的顺序，访问临界资源

**流程**
1. 向协调者发送**请求授权**信息，1次消息交互；
2. 协调者向程序**发放授权**信息，1次消息交互；
3. 程序使用完临界资源后，向协调者发送**释放授权**，1次消息交互。

**优点**
**直观、简单、信息交互量少、易于实现**，并且所有程序只需和协调者通信，程序之间无需通信。

**缺点**
协调者会成为系统的**性能瓶颈**，容易引发**单点故障**问题

### **分布式算法**
程序要访问临界资源时，先向系统中的**其他程序**发送一条**请求消息**，在接收到所有程序返回的**同意消息**后，才可以**访问临界资源**。其中，请求消息需要包含所请求的**资源、请求者的ID，以及发起请求的时间**。也常使用组播和逻辑时钟的算法。

**缺点**
在大型系统中使用分布式算法，**消息数量**会随着需要访问临界资源的程序数量呈**指数级增加**，容易导致高昂的**沟通成本**

### **令牌环算法**
所有**程序构成一个环结构**，**令牌**按照顺时针（或逆时针）方向在程序之间**传递**，收到令牌的程序有权**访问临界资源**，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序

**优点**
**公平性高**，在改进单点故障后，稳定性也很高，**适用于系统规模较小**，并且系统中每个程序**使用临界资源的频率高**且使用**时间比较短**的场景。

### **两层结构的分布式令牌环算法**
广域网由多个局域网组成，因此在该算法中，局域网是较低的层次，广域网是较高的层次。每个局域网中包含若干个局部进程和一个协调进程。局部进程在逻辑上组成一个环形结构，在每个环形结构上有一个局部令牌T在局部进程间传递。局域网与局域网之间通过各自的协调进程进行通信，这些协调进程同样组成一个环结构，这个环就是广域网中的全局环。在这个全局环上，有一个全局令牌在多个协调进程间传递。

## 主节点
在一个分布式集群中负责对其他节点的协调和管理

### **Bully算法**
活着的节点中，选取**ID最大的节点**作为主节点。

**优点**
选举**速度快、算法复杂度低、简单易实现**。

**缺点**
每个节点有**全局的节点信息**，额外信息存储较多；其次，任意一个比当前主节点ID大的新节点或节点故障后恢复加入集群的时候，都可能会触发**重新选举**，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主。

**流程**

- 集群中每个节点判断自己**是否为当前活着的节点中ID最大**的，如果是，则直接向其他节点**发送Victory**消息，宣誓自己的主权；
- 如果自己不是当前活着的节点中ID最大的，则**向比自己ID大**的所有节点**发送Election**消息，并**等待其他节点的回复**；
- 若在**给定的时间范围**内，本节点**没有收到**其他节点回复的**Alive消息**，则认为自己成为主节点，并向其他节点**发送Victory消息**，宣誓自己成为主节点；若接**收到**来自比自己ID大的节点的**Alive消息**，则**等待其他节点发送Victory消息**；
- 若本节点**收到**比自己ID小的节点发送的**Election**消息，则**回复一个Alive消息**，告知其他节点，我比你大，重新选举。

### **Raft算法**

典型的多数派投票选举算法

**Leader**，即主节点，同一时刻只有一个Leader，负责协调和管理其他节点；
**Candidate**，即候选者，每一个节点都可以成为Candidate，节点在该角色下才可以被选为新的Leader；
**Follower**，Leader的跟随者，不可以发起选举。

- **初始化**时，所有节点均为**Follower状态**。
- **开始选主**时，所有节点的状态由**Follower转化为Candidate**，并向其他节点发送**选举请求**。
- 其他节点根据接收到的选举请求的**先后顺序**，回复是否同意成为主。这里需要注意的是，在每一轮选举中，**一个节点只能投出一张票**。
- 若发起选举请求的节点获得**超过一半的投票**，则**成为主节点**，其**状态转化为Leader**，**其他节点**的状态则由**Candidate降为Follower**。Leader节点与Follower节点之间会**定期发送心跳包**，以检测主节点是否活着。
- 当Leader节点的任期到了，即发现其他服务器开始**下一轮选主周期**时，Leader节点的状态由**Leader降级为Follower**，进入新一轮选主。

**优点**
**选举速度快、算法复杂度低、易于实现**

**缺点**
要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此**通信量大**。

该算法选举**稳定性比Bully算法好**，这是因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得**投票数过半**，才会导致**切主**

### **ZAB算法**

具有**优先级**的民主投票，尽可能保证**数据最新性**,**ID大的节点优先成为主**

- 3种角色：Leader，Follower，Observer。
- 4种状态：Looking,Leading,Following,Observing。
- 每个节点有三元组(server_Id,server_zxID,epoch)。

**选主原则**

**server_zxID最大**者成为Leader,若server_zxID相同，则**server_id最大**者成为Leader。

**优点**
性能稳定。

**缺点**
选举**时间较长**，容易出现**广播风暴**，需要知道所有节点的zxId和serverId 

## 分布式共识
在多个节点均可独自操作或记录的情况下，使得**所有节点**针对某个**状态达成一致**的过程。分布式共识包括两个关键点，获得**记账权**和**所有节点或服务器达成一致**

### **PoW算法**
以每个节点或服务器的计算能力，即**算力**，来**竞争记账权**

比特币系统设置的总量2100万个比特币，系统中的每个节点都有记账权，成功**获得记账权**的节点将**获得记账奖励**，这个奖励就来自于这个总量，这个就是比特币的来源。因为和黄金采矿原则类似，谁付出谁得到，因此记账的过程也被称形象的称为挖矿。

**工作量证明过程**
利用区块的index、前一个区块的哈希值、交易的时间戳、区块数据、nonce值，通过SHA256计算出一个**哈希值**，这里的nonce值是无法直接猜出的，所以只能大量的**穷举尝试**并且每次尝试都需要一定的计算量，因此需要大量的计算量才能得到一个**正确的nonce值**。每次为了争取一个区块的记账权，而获得正确nonce值的过程就是一个PoW（工作量证明）

### **PoS算法**
由**系统权益代替算力**来决定区块记账权，拥有的权益越大，获得记账权的概率就越大

### **DPoS算法**
是一种委托权益证明算法。持有币的人可以**通过投票选举**出一些节点，来作为代表去记账

## 实现分布式事务

### **XA协议的二阶段提交**
XA协议可以分两部分，即**事务管理器**和**本地资源管理器**。

- 事务管理器作为**协调者**，负责各个本地资源的提交和回滚；
- 而资源管理器就是分布式事务的**参与者**，通常由数据库实现

**执行过程**
分为**投票**（voting）和**提交**（commit）两个阶段。协调者**下发请求事务操作**，参与者将**操作结果通知协调者**，协调者根据所有参与者的**反馈结果决定**各参与者是要**提交操作还是撤销操作**

**缺点**
**同步阻塞**问题，**单点故障**问题，提交阶段由于网络问题等导致的**数据不一致**问题

三阶段提交方法
为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了超时机制和准备阶段
同时在协调者和参与者中引入超时机制。如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务。
在第一阶段和第二阶段中间引入了一个准备阶段，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。

CanCommit、PreCommit、DoCommit三个阶段

PreCommit阶段。

协调者根据参与者的回复情况，来决定是否可以进行PreCommit操作。

如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：

发送预提交请求。协调者向参与者发送PreCommit请求，进入预提交阶段。
事务预提交。参与者接收到PreCommit请求后执行事务操作，并将Undo和Redo信息记录到事务日志中。
响应反馈。如果参与者成功执行了事务操作，则返回ACK响应，同时开始等待最终指令。
假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：

发送中断请求。协调者向所有参与者发送“Abort”消息。
中断事务。参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的中断操作。

2PC和3PC这两种方法，有两个共同的缺点，一是都需要锁定资源，降低系统性能；二是，没有解决数据不一致的问题。基于分布式消息的重试机制，得到最终一致性方案

刚性事务，遵循ACID原则，具有强一致性。比如，数据库事务。
柔性事务，其实就是根据不同的业务场景使用不同的方法实现最终一致性，也就是说我们可以根据业务的特性做部分取舍，容忍一定时间内的数据不一致

BASE理论
基本可用：分布式系统出现故障的时候，允许损失一部分功能的可用性。比如，某些电商618大促的时候，会对一些非核心链路的功能进行降级处理。
柔性状态：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一种柔性状态。
最终一致性：事务在操作过程中可能会由于同步延迟等问题导致不一致，但最终状态下，数据都是一致的。

与普通锁不同的是，分布式锁是指分布式环境下，系统部署在多个机器中，实现多进程分布式互斥的一种锁

数据库实现，缺点，单点故障，死锁
Redis等中间件实现，setnx(key, value)函数来实现分布式锁。key和value就是基于缓存的分布式锁的两个属性，其中key表示锁id，value = currentTime + timeout，缺点，通过超时时间控制锁不靠谱（网络问题）

zookeepeer实现，基于树形数据存储结构实现分布式锁。每个进程请求创建一个临时节点，确认是否是该树下最小子节点，若是，则获取锁，若本进程对应的临时节点编号不是最小的，则分为两种情况：

a. 本进程为读请求，如果比自己序号小的节点中有写请求，则等待；
b. 本进程为写请求，如果比自己序号小的节点中有读请求，则等待

在整个分布式锁的竞争过程中，大量的“Watcher通知”和“子节点列表的获取”操作重复运行，并且大多数节点的运行结果都是判断出自己当前并不是编号最小的节点，继续等待下一次通知，而不是执行业务逻辑，若本进程对应的临时节点编号不是最小的，则继续判断：
若本进程为读请求，则向比自己序号小的最后一个写请求节点注册watch监听，当监听到该节点释放锁后，则获取锁；
若本进程为写请求，则向比自己序号小的最后一个请求节点注册watch监听，当监听到该节点释放锁后，获取锁

分布式体系结构

集中式结构就是，由一台或多台服务器组成中央服务器，系统内的所有数据都存储在中央服务器中，系统内所有的业务也均先由中央服务器处理。多个节点服务器与中央服务器连接，并将自己的信息汇报给中央服务器，由中央服务器统一进行资源和任务调度：中央服务器根据这些信息，将任务下达给节点服务器；节点服务器执行任务，并将结果反馈给中央服务器。

Redis集群是一个非集中式集群管理系统，没有中心节点，不会因为某个节点造成性能瓶颈，每个节点均支持数据存储，且采用分片存储方式，提高了写的并发能力。同时，每个节点的设计采用主备设计，提高了数据的可靠性。

Akka集群是一个完全去中心化的集群管理系统，节点之间都是P2P的连接模式，通过Gossip协议来进行通信，节点之间有角色划分，负责数据存储的节点会进行存储数据。

Redis集群也是P2P的网状连接模式，但是基于key-value的数据库模型，每个节点都可以执行数据的计算和存储。此外，Redis集群引入了哈希槽的概念，来解决数据的分片存储问题。

Cassandra集群的结构是一致性哈希的P2P，节点会构成一个环结构，通过哈希映射来选择对应的节点

什么是单体调度？
分布式系统中的单体调度是指，一个集群中只有一个节点运行调度进程，该节点对集群中的其他节点具有访问权限，可以搜集其他节点的资源信息、节点状态等进行统一管理，同时根据用户下发的任务对资源的需求，在调度器中进行任务与资源匹配，然后根据匹配结果将任务指派给其他节点

单体调度器拥有全局资源视图和全局任务，可以很容易地实现对任务的约束并实施全局性的调度策略

单体调度的特征，可以总结为以下四点：

单体调度器可以很容易实现对作业的约束并实施全局性的调度策略，因此适合批处理任务和吞吐量较大、运行时间较长的任务。
单体调度系统的状态同步比较容易且稳定，这是因为资源使用和任务执行的状态被统一管理，降低了状态同步和并发控制的难度。
调度算法只能全部内置在核心调度器当中，因此调度框架的灵活性和策略的可扩展性不高。
单体调度存在单点故障的可能性

两层调度结构对应的就是两层调度器，资源的使用状态同时由中央调度器和第二层调度器管理，中央调度器从整体上进行资源的管理与分配，将资源分配到第二层调度器；再由第二层调度器负责将资源与具体的任务配对，因此第二层调度可以有多个调度器，以支持不同的任务类型。

而关于第一层的调度算法，通常有最大最小公平算法和主导资源公平算法等

最大最小公平算法适用于单一类型的资源分配场景，而主导资源公平算法适用于多种类型资源混合的场景。并且，最大最小公平算法从公平的角度出发，为每个用户分配不多于需求量的资源；而主导资源公平算法从任务出发，目的在于尽量充分利用资源使得能够执行的任务越多越好。

共享状态调度器，通过将单体调度器分解为多个调度器，每个调度器都有全局的资源状态信息，从而实现最优的任务调度，提供了更好的可扩展性

乐观并发调度，强调事后检测，在事务提交时检查是否避免了冲突：若避免，则提交；否则回滚并自动重新执行。也就是说，它是在执行任务匹配调度算法后，待计算出结果后再进行冲突检测。

悲观并发调度，强调事前预防，在事务执行时检查是否会存在冲突。不存在，则继续执行；否则等待或回滚。也就是说，在执行任务匹配调度算法前，通过给不同的Framework发送不同的资源，以避免冲突
