# 商品详情查询流程

获取商品图片

获取商品，型号 价格

获取用户地址

获取组合套餐信息

适配车型信息

供应商信息

店铺推荐列表 猜你喜欢列表

商品评论

实时购买，滚动数据

# 确认订单流程

用户过审检查

查询用户地址填充

购买商品区域禁售查询，过滤

合并相同型号商品，计算型号价格，购买规则填充，库存填充，商品，库存状态检查

商品按照供应商拆单，加载优惠券（店铺，平台）列表，计算跨店满减金额，计算税费，汇总订单价格参数，计算红包金额，

 
	
	- 初始化商品型号：根据商品型号查询商品型号信息
		- SKU基准价
		- 型号信息
	- 判断商品是否处于禁售区域
	- 禁售商品库存置为0
	- 排除商品在活动中，但是商品下存在型号不处于活动中的型号
	- 活动商品库存计算，多个活动按照优先级获取活动库存
	- 获取对应活动商品库存
	- 计算普通商品库存
 
# 生成订单流程
 
## 借助 WebAsyncTask 建立异步任务

### 验证

**根据token获取用户信息**

**验证用户是否初审通过**

**是否使用红包，可用红包余额验证**

**判断是否存在处于活动中的商品**，listGoodsAttributeByAuth

- 建立缓存，超时1分钟，Marketing:GoodsAttributeSaleAuthCO:GoodsAttributeId:1----536498
	- 通过库存计算器查询对应的SKU库存信息，并缓存（supplierId，stockSource，goodsId，activity，goodsMoq，authNumber，totalStock，requestNo，goodsAttributeId）

**活动商品创建订单** 

- 获取购买资格 getBuyAuth
	- Marketing:Activity:FlashSale:order_lock（分布式锁 5S超时）
	- 获取前面缓存商品信息
	- 根据 authNumber 查询此次商品购买 库存是否充足
		- 充足：redis cas更新 authNumber
		- 不充足：返回库存不足信息
	- 解锁
- 无购买资格资格 return  排队的人太多，被挤掉了
- 有购买资格
	- 生成 Order:Activity:Submit:reqBatchNo 为key，将订单请求数据 存入 ‘create’ 作为 hashKey 的 redis缓存中 30分钟
	- 发送消息  OrderSubmitSuccessMessage
		- 1 消息进行生成真实订单的处理请求，创建订单，把生成订单数据存入 ‘orders’ 作为 hashKey 的 redis缓存中
		- 2 订单生成结果数据 存入 ‘result’ 作为 hashKey 的 redis缓存中  
	- 让APP进行外部轮询
	- 内部轮询（超时返回，“订单已经提交成功！请到订单列表查询订单的状态！”）
		- 调用订单的接口查看处理的结果 
			- 从redis中查询 hashKey = result的 订单生成结果数据
				- CREATED：从redis中获取  reqBatchNo+‘orders‘ redis订单数据
				- ABORTED：return SOLD_OUT 已抢完 状态
				- 其他：继续循环（5S一查）

问：先扣减库存 ，消息中 订单生成失败后怎么办，活动库存信息过期为1M
唯一的缺点 分布式锁 锁定的是整个活动

**普通商品创建订单**