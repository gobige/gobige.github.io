### redo log 和binlog
mysql更新操作采用WAL(write-ahead logging)技术，使用 redo log，先将更新写入日志，空闲时在写入磁盘，表示记录这个数据页做了什么改动
Innodb的redo log是一组4个文件，每个文件1GB大小空间，有两个标志位wirte pos和checkpoint，

![此处输入图片的描述](http://pev96mxgw.bkt.clouddn.com/img/mysql/1.png)

write pos表示当前记录的位置，checkpoint表示当前要擦除的位置，wirite pos不断的向后移动写入redo log，
checkpoint的不断将rodo log数据写入磁盘，当writelog追上checkpoint后，就要等待checkpoint清理出一片空间后才能继续写入
从而保证了数据库发生异常重启，之前的记录都不会消失，被称为crash-safe，redo log作为引擎层特有日志

innodb_flush_log_at_trx_commit 设置成1，表示每次事务的redo log都直接持久化到磁盘。

server层由binlog做归档日志记录所有的逻辑操作，所有引擎都可以使用，以前写的日志不会覆盖，写在redolog pre 和redolog commit之间，两阶段提交能够保证了数据存储的有效性。binlog有两种模式，记sql语句和记录行行内容前后的状态

数据库恢复：1首先找到最近的一次全量备份，2从上次开发备份时间开始，将备份的binlog依次取出来，进行重放。

sync_binlog 参数设置为1 表示每次事务的binlog都持久化到磁盘，保证mysql异常重启后binlog不丢失。

### 数据库隔离级别实现
未提交读，直接**返回记录**上的最新值
提交读和可重复读是使用**视图**来访问数据，可重复读是在事务启动的时候创建的，读提交级别是在每个sql启动时创建的。
串行化时直接进行**加锁**。

每条记录在更新的时候会同时记录一条回滚操作，不同时刻启动的事务会有不同的read-view，在不同view里面一条记录有不同的值，这就是数据库多版本控制(MVCC).
当系统中没有比回滚日志更早的view时，日志就会删除，长事务会保存很老的事务视图，占用大量的存储空间。

### 事务启动方式
1 set autocommit=0，关闭自动提交事务，然后使用commit提交事务  2 显式使用 begin/start transaction语句

查询大于60s的长事务
``java
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
``

### 索引搜索模型
哈希表：通过链表结构存储索引数据，等值搜索很快，但是区间查找效率就不高
有序数组：等值和，区间查找效率都很高，但是不利于数据的更新，插入，删除记录会挪动其他数据，成本太高，只适合用于静态存储引擎。
搜索树：每一个索引在innodb里面对应一棵B+树。
- 主键索引被称为聚簇索引，其叶子节点存的是整行数据
- 非主键索引称为二级索引，其叶子节点存储的是主键的值,非主键索引查询方式，先搜索非主键索引树，通过拿到主键进行主键索引树的搜索（称为回表）。
- 因为非主键索引会存储主键索引的值，所以如果主键索引越长，那么非主键索引叶子节点占用的空间就越大，而数据占用空间膨胀会导致页分裂。索引一般提倡使用自增主键。（在只有一个索引，而且该索引为唯一索引的情况下，业务字段是适合做主键的）
- 由于非主键索引k的叶子节点上面已经有主键的id值，所以如 select id from table where k bettwen 2 and 6 等sql语句时，索引K以及覆盖了我们的查询需求，我们称为覆盖索引，覆盖索引可以减少速度搜索次数
- 对于联合索引（a,b），针对a的索引可以复用，可能会需要另外建立b的索引，那么a的如果比b的占用空间大，在建立b单独索引时就会节省空间

- 索引下推，5.6版本以后引入的索引下推，在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

- 重建主键索引（删除，创建）都会将整个表重建，而且这个表上的其他非主键索引也会失效，可以使用alter table engine = innodb代替


### 全局锁，表级锁，行级锁
全局锁sql：Flush tables with read lock;常用于全库逻辑备份，备份时不加锁会造成多表操作时事务的不一致性，比如转账，购买业务场景
其他全局锁方法
1：mysql自带的mysqldump逻辑备份工具只适用于使用事务引擎的库表 （–single-transaction参数）
2：set global readonly=true （如果执行过程中客户端断开，数据库会一直保持readonly状态，而ftwrl不会，2通常用于判断主从库的逻辑）

表级锁
- lock tables T read/write，除了限制别的线程读写外，也限定了本线程接下来的操作对象（thread1 lock table1 read，table2 write；那么thread2 对 t1，t2读写都不可进行；自身线程不能对T1做write操作）
- MDL,访问表时自动加上，mysql5.5以后在对一个表做增删改查时，加MDL读锁；当对结构做变更操作时，加MDL写锁。
	- 读锁之间不互斥
	- 读写锁和写锁之间互斥
在热点查询表中执行DDL，很有可能造成整个数据库挂掉，原因是执行DDL线程阻塞后面的请求，而如果DDL线程前面的请求一直不释放MDL锁的话，客户端的不断重试，生成新session，数据库线程爆满。这种情况在做DDL时，先将长事务kill掉
事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。


解锁：unlock tables
