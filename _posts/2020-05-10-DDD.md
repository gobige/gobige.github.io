---
layout: post
title: 'DDD领域驱动相关知识'
subtitle: 'DDD领域驱动相关知识和总结'
date: 2020-05-10
categories: 架构
author: yates
cover: 'http://cctv.com'
tags: 架构
---

### 领域模型

领域：用来确定范围的，范围即边界，领域就是这个**边界内**要解决的**业务问题域**

子域：领域进一步划分为子领域。每个子域对应一个更小的问题域和业务范围。根据自身重要性和功能属性划分为三类子域
	- 通用域：被多个子域使用的通用功能。认证，权限
	- 核心域：产品和公司核心竞争力功能。
	- 支撑域：非产品和公司核心竞争力功能，也不包含通用功能子域，具有启用特性。数据字典
	
通用语言：在事件风暴过程中，通过**团队交流达成共识**，能够**简单，清晰，准确**描述**业务含义和规则**的语言

事件风暴建立通用语言到领域对象设计和代码落地过程

1. 事件风暴
2. 领域故事分析
3. 提取领域对象（通过表格记录对象和属性）
4. 领域对象与代码模型映射
5. 代码落地

界限上下文，界限是领域边界，上下文是语义环境。用来封装通用语言和领域对象，提供上下文环境，保证**领域之内一些术语，业务相关对象有确切的含义，没有二异性**


**商业模式的不同，不同场景导致核心域的划分不同。**

领域建模和微服务建设的过程和方法基本类似，其核心思想就是将问题域逐步分解，降低业务理解和系统实现的复杂度

### 实体和值对象

**实体和值对象是组成领域模型的基础单元**

**实体**

拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。

- 业务形态：领域模型中实体是多个属性，操作和行为的载体
- 代码形态：实体类（通常充血模型），包含实体属性和方法，通过方法实现实体自身业务逻辑
- 运行形态：以DO的形式存在，有唯一ID，尽管实体对象数据进行多次修改，依然是同一个实体
- 数据库形态：实体可能对应0,1，N 个数据库持久化对象。依次如：多个价格配置数据计算后折扣实体；注册用户；用户信息和账户信息

**值对象**

通过对象属性值识别对象，将多个相关属性组合为一个概念整体。**本质上是一个集**。值对象不可变。

DDD引入值对象希望从领域模型设计出发，而不是先设计数据模型，减少数据库表数量和表之间复杂依赖关系，简化数据库设计，提高数据库性能

- 业务形态：DDD模型中基础对象，若干属性的集合，和实体构成聚合。
- 代码形态：实体类属性（基本数据类型）或属性集合（Class类）
- 运行形态: 除了值对象初始化和整体替换，其他行为很少
- 数据库形态：传统建模，一个实体主表对应N个实体从表。**值对象属性值和实体对象属性值保存同一个数据库实体表中**

实体对象和值对象在不同场景下，会设计出不同结果。例：收货地址由于经常修改，作为实体对象。
 
### 聚合和聚合根

**聚合**

领域模型内的实体和值对象就好比个体，而能让**实体和值对象协同工作的组织**就是聚合，它用来确保这些领域对象在**实现共同的业务逻辑时，能保证数据的一致性**。

聚合在DDD分层架构里**属于领域层**，领域层包含了多个聚合，共同实现核心业务逻辑。聚合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚

**聚合根**

避免由于复杂数据模型缺少统一**业务规则控制**，导致数据不一致。

如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为**根实体**，它不仅是实体，还是聚合的**管理者**。

聚合之间，对外接口都以聚合根ID为关联接受外部任务和请求。

**聚合根选择**

是否独立生命周期，是否全局唯一id；是否可创建，修改其他对象；是否专门模块管理实体

**聚合构建流程**

1. 事件风暴梳理出所有**实体和值对象**
2. 找出聚合根
3. 根据业务单一职责和高内聚原则，找出与聚合根管理紧密实体和值对象
4. 根据聚合根和实体，值对象，画出引用和依赖模型
5. 根据业务语义和上下文划分多个聚合到同一个界限上下文

**聚合的一些设计原则**

- 在一致性边界内建模真正的不变条件
- 设计小聚合
- 通过唯一标识引用其它聚合
- 在边界之外使用最终一致性
- 通过应用层实现跨聚合的服务调用


### 领域事件

用来表示领域中发生的事件。领域事件将导致进一步业务操作，实现业务解耦同时，有助于形成完整业务闭环

一次事务最多只能更改一个聚合的状态。如果一次业务设计多个聚合状态修改，应采取**领域事件最终一致性**。

微服务内领域事件，发送方聚合将事件发布到事件总线，订阅方接收事件数据完成后续业务操作
微服务外领域事件，通过引入分布式事务来解决数据一致性

**领域事件处理**

事件构建和发布：事件唯一标识，发布时间，事件类型，事件源以及业务属性；通过应用服务或领域服务发布**事件总线或消息中间件**；也可**事件表定时轮询，数据库日志获取增量事件**

事件数据持久化：本地业务数据库事件表中。共享事件数据库中，需保证分布式事务数据一致性

事件总线：服务外事件表保存，异步发送消息中间件；服务内直接分发

消息中间件：市面上 中间件产品，MQ,Kafka

事件接收和处理


DDD四层结构

- 用户接口层：**用户显示和解释用户指令**
- 应用层：主要面向用例和流程相关操作 。协调多个聚合服务和领域对象完成**服务编排和组合**
- 领域层：包含聚合根，实体，值对象，领域对象。实现企业核心业务逻辑。表达**业务概念，业务状态和业务规则**。领域中某些功能，单一实体无法实现时，领域服务通过组合**聚合内多个实体，实现复杂业务逻辑**
- 基础层：威奇塔各层提供通用技术和基础服务。三方工具，驱动，消息中间件，网关，文件，缓存，数据库服务

**严格分层架构**

服务逐层对外封装，组合，依赖关系清晰，一层引用一层

**松散分层架构**

依赖关系比较复杂,难管理，允许跨层调用；容易是核心业务逻辑外泄

**微服务架构的演进**

可以聚合为基础单元，完成领域模型和微服务架构的演进。聚合可以作为一个整体，在**不同的领域模型**之间**重组或者拆分**，或者直接将一个聚合独立为微服务

**微服务内服务的演进**

在微服务内部，实体的方法被领域服务组合和封装，领域服务又被应用服务组合和封装

**三层结构和DDD结构区别**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/1.jpg)



## 常见微服务架构

**整洁架构**

整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/2.jpg)

- 领域模型的主体是实体，一个实体可以是一个带方法的对象，也可以是一个数据结构和方法集合。
- 领域服务实现涉及多个实体的复杂业务逻辑。
- 应用服务实现与用户操作相关的服务组合与编排，它包含了应用特有的业务流程规则，封装和实现了系统所有用例。
- 最外层主要提供适配的能力，适配能力分为主动适配和被动适配。
	- 主动适配主要实现外部用户、网页、批处理和自动化测试等对内层业务逻辑访问适配。
	- 被动适配主要是实现核心业务逻辑对基础资源访问的适配，比如数据库、缓存、文件系统和消息中间件等。红圈内的领域模型、领域服务和应用服务一起组成软件核心业务能力。
	
**六边形架构**

应用是通过端口与外部进行交互的

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/3.jpg)

- 红圈内的六边形实现应用的核心业务逻辑；
- 外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以 API 主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。


不管是DDD还是整洁还是六边形都考虑了**前端需求的变**和**领域模型的不变**

中台本质上是领域的子域，它可能是核心域，也可能是通用域或支撑域。通常大家认为阿里的中台对应 DDD 的通用域，将通用的公共能力沉淀为中台，对外提供通用共享服务。

**项目级微服务**

与前端应用集成，一起完成特定业务；通常遵循分层架构。核心逻辑在应用层完成，通过API网关为前台提供服务，前后端分离；微服务之间集成通常在应用层

**企业级中台微服务**

某个职责单一中台微服务，企业级业务流程需将多个这样微服务组合起来才能完成

通过在中台微服务上增加一层，例如BFF来完成跨微服务服务组合和编排

BFF 微服务与其它微服务存在较大的差异，就是它没有领域模型，因此这个微服务内也不会有领域层。BFF 微服务可以承担**应用层和用户接口层**的主要职能，完成各个中台微服务的服务组合和编排，可以适配不同前端和渠道的要求

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/4.jpg)


## 中台 

**中台的关键词：共享、联通、融合和创新**，快速响应能力和**企业级**的无缝联通和融合能力

阿里业务中台的前身是共享平台，而原来的共享平台更多的被当作资源团队，他们承接各业务方的需求，并为业务方在基础服务上做定制开发。 阿里业务中台的目标是把核心服务链路（会员、商品、交易、营销、店铺、资金结算等）整体当作一个平台产品来做，为前端业务提供的是业务解决方案，而不是彼此独立的系统

业务中台的建设可采用领域驱动设计方法，通过领域建模，将可复用的公共能力从各个单体剥离，沉淀并组合，采用微服务架构模式，建设成为可共享的通用能力中台。

**中台建模流程**

1. 按照业务流程或功能属性，集合，将业务域细分为多个中台；根据功能属性和重要性归类核心中台或通用中台
2. 选取中台，根据用例，业务场景完成事件风暴，找出实体，聚合和限界上下文。依次建立领域模型
3. 以主领域模型为基础，扫描其他领域模型，检查是否存在重复或重组领域对象，提炼重构主领域模型，形成最终领域模型设计
4. 完成所有主领域模型对比，重构
5. 根据模型完成微服务设计

**中台业务模型构建**

- 自顶向下：先做顶层设计，从最高领域逐级分解为中台，分别建立领域模型，根据业务属性分为通用中台或核心中台。适用于全新应用系统建设，或旧系统推翻重建情况。
- 自底向上：基于业务和系统现状完成领域建模，首先完成系统所在业务域领域建模，找出同类，相似业务领域模型，重构模型，重组对象。
	- 锁定系统所在业务域，构建领域模型
	- 对齐业务域，构建中台业务模型
	- 中台归类，根据领域模型设计微服务
	
事件风暴

	- 产品愿景：对产品顶层价值设计，业务范围，目标用户，核心价值和愿景，与其他同类产品差异和优势
	- 业务场景分析，从**用户视角，根据业务流程和用户旅程**，采用**用例和场景**，探索典型场景，找出**领域事件，实体和命令等领域对象**，支撑领域建模，尽量遍历所有**业务细节**，充分发表意见
	- 领域建模：根据领域对象，分析**实体**之间**依赖关系**组成聚合，划定上下文，建立模型及模型间依赖
	- 微服务拆分和设计：将领域模型作为微服务拆分一个重要依据。同时考虑敏态和稳态业务分离，弹性伸缩，安全性，技术异构等非业务因素。
	
	
## 微服务代码模型

**微服务一级目录结构**

按照DDD分层架构职责定义

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/5.jpg)

**用户接口层**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/6.jpg)

- Assembler：实现DTO和领域对象之间转换和数据交换。
- Dto：数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域对象与外界隔离
- Facade：粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理

**应用层**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/7.jpg)

- Event：publish存放事件发布相关代码，subscribe存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现
- Service：对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务

**领域层**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/8.jpg)

- Aggregate：根据实际项目的聚合名称命名；聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务
- Entity：存放聚合根、实体（充血模型）、值对象以及工厂模式（Factory）相关代码，同一实体相关的业务逻辑都在实体类代码中实现
- Event：存放事件实体以及与事件活动相关的业务逻辑代码。
- Service：存放领域服务代码，多个实体组合出来的一段业务逻辑
- Repository：存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法，一个聚合对应一个仓储

**基础层**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/9.jpg)

- Config：存放配置相关代码
- Util：存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码

**聚合之间的代码边界一定要清晰；一定要有代码分层的概念**

整理领域对象，将其整理到**表格**中

- 设计实体：通常实体和微服务数据库实体一一对应的。实体采用充血模型，在实体类内实现实体的全部业务逻辑。如比如地址实体有新增和修改地址的方法
- 找出聚合根：如个人客户聚合里，个人客户这个实体是聚合根，它负责管理地址、电话以及银行账号的生命周期
- 值对象：如：在个人客户聚合中，客户拥有客户证件类型，它是以枚举值的形式存在，所以将它设计为值对象
- 领域事件：确定领域事件发生在微服务内还是微服务之间，设计事件实体对象，事件的发布和订阅机制，以及事件的处理机制
- 领域服务：对多个实体和实体方法进行组合，完成核心业务逻辑
- 仓储：数据查询和持久化操

并思考：

- 分析微服务内有哪些服务？
- 服务所在的分层？
- 应用服务由哪些服务组合和编排完成？
- 领域服务包括哪些实体的业务逻辑？
- 采用充血模型的实体有哪些属性和方法？
- 有哪些值对象？哪个实体是聚合根等？
- 最后梳理出所有的领域对象和它们之间的依赖关系，我们会给每个领域对象设计对应的代码对象，定义它们所在的软件包和代码目录。


**典型的领域模型**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/10.jpg)

**代码结构**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/11.jpg)



### 边界

**演进式架构**就是以支持增量的、非破坏的变更作为第一原则，同时支持在应用程序结构层面的多维度变化

**微服务的过度拆分会使软件维护成本上升，若微服务内部的逻辑和代码边界很清晰，你就可以随时根据需要，拆分出新的微服务，实现微服务的架构演进**

**逻辑边界**

同一业务领域或应用内紧密关联的对象所组成的**不同聚类的组合之间的边界**

业务端以聚合为单位进行业务能力的重组，在微服务端以聚合的代码目录为单位进行微服务代码的重组。
按照 DDD 方法设计的微服务逻辑边界清晰，业务高内聚，聚合之间代码松耦合，因此在领域模型和微服务代码重构时，我们就不需要花费太多的时间和精力了

**物理边界**

从**部署**和运行的视角来定义微服务之间的边界

**代码边界**

用于微服务内的**不同职能**代码之间的隔离

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/12.jpg)

**数据对象视图**

数据持久化对象 PO(Persistent Object)，与数据库结构一一映射，是数据持久化过程中的数据载体。
领域对象 DO（Domain Object），微服务运行时的实体，是核心业务的载体。
数据传输对象 DTO（Data Transfer Object），用于前端与应用层或者微服务之间的数据组装和传输，是应用之间数据传输的载体。
视图对象 VO（View Object），用于封装展示层指定页面或组件的数据

### 微前端

前端设计时我们需要遵循**单一职责和复用原则**，按照领域模型和微服务边界，将前端页面进行拆分。
同时构建多个可以**独立部署、完全自治、松耦合的页面组合**，其中**每个组合只负责特定业务单元的 UI 元素和功能**，这些页面组合就是微前端

前端项目团队只需要完成企业级前端主页面与业务单元的融合，前端只关注前端主页面与微前端页面之间的集成

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/13.jpg)
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/14.jpg)

## 战略设计

战略设计是根据用户旅程分析，找出领域对象和聚合根，对实体和值对象进行聚类组成聚合，划分限界上下文，建立领域模型的过程

如图

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/15.jpg)

## 战术设计

梳理微服务内的领域对象，梳理领域对象之间的关系，确定它们在代码模型和分层架构中的位置，建立领域模型与微服务模型的映射关系，以及服务之间的依赖关系

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/ddd/16.jpg)


## 微服务的演进策略

**绞杀者策略**

逐步剥离业务能力，用微服务逐步替代原有单体系统的策略

**修缮者策略**

在现有系统的基础上，剥离影响整体业务的部分功能，独立为微服务，比如高性能要求的功能，代码质量不高或者版本发布频率不一致的功能


## 微服务设计原则

要领域驱动设计，而不是数据驱动设计，也不是界面驱动设计

要边界清晰的微服务，而不是泥球小单体。

要职能清晰的分层，而不是什么都放的大箩筐。

要做自己能 hold 住的微服务，而不是过度拆分的微服务