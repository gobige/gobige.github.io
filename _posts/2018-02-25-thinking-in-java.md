---
layout: post
title: 'java编程思想 笔记和随想'
subtitle: '《java编程思想》笔记和随想'
date: 2018-02-25
categories: java
author: yates																																									
cover: 'www.baidu.com'
tags: java
---

javadoc 只会对public和 protect 访问级别进行文档生成可见，

|Modifier|Class|Package|Subclass|World
:------:|:----------------:|:---------------:|:----------------:|:--------:|
|public|	Y|	Y|	Y|	Y
|protected|	Y|	Y|	Y|	N
|default|	Y|	Y|	N|	N
|private|	Y|	N|	N|	N

@see：引用其他类的文档
@version：版本
@author：作者

整数除法直接去除小数

逗号运算符，递增，递减运算符，按位运算符，算术运算符，移位运算符，关系运算符，逻辑运算符，三元运算符，赋值运算符，

重载：每个重载的方法须采取独一无二的自变量类型列表
基本类型的重载：结构类型小的自动转型为大的基本类型进行方法重载匹配
每个类都需要一个构造函数，编译器会创建一个默认构造函数
This关键字：位于方法内部，一个引用表示当前调用方法的对象，一个类里面方法调用当前类其他方法无需this关键字，编译器自动填充

static和oop的思想的冲突，个人觉得怎么好用，怎么用

类变量，编译器会自动赋值为0，null，false等值，方法变量编译器必须强制初始化变量

Java之所以安全，是因为牺牲运行效率来进行代码的检查，数组越界，null指针，变量初始化等

Import搜索路径：通过配置的classpath环境变量，进行导入class文件的搜索；当相同路径下有两个相同命名class文件时，使用最新的文件；java编译器搜索自己类路径的任何地方，所以一旦它发现一个可引用的类，就会使用它；若在搜索过程中发现了“错误的”一个，它就会停止搜索（工作中debug，两个工程，不同module相同路径，相同的类，debug指向错误）建议无论什么时候都保存一个java类都独一无二命名

每个编译单元都只能有一个类的访问控制符为public

类的构造函数设置privite，只有本身static静态区能进行对象创建

代码的重复使用方式：继承，合成

对象初始化的位置，构造函数，static代码区，在需要使用的地方赋值；使用没有初始化的变量会导致异常

多多使用多态，多态带来的好处，忽略具体实现的细节，只与基类打交道，分离具体信息，动态绑定

使用组合还是继承，区别于是否需要从新类向基类继续向上转型

**Final修辞常量**
final修辞的常量于编译期进行加载
final修辞的常量不一定于编译期就赋值
Final修辞的常量必须在使用前赋值
被final修辞的域一个表示该区域引用不可变，基本类型值不可变，引用类型引用不可变
既是static又是final的域常用大写加下划线方式命名

**final修辞方法**
目的 
- 1锁定方法，以免子类继承该方法；
- 2早期提高效率，将方法作为内嵌调用，hotspot已经对此进行优化

**final修辞类**
目的
- 禁止其他类继承该类

String，枚举，java.lang.Number的部分子类，long和double等包装类型，binginter，bigdecimal等大数据类都是final修辞

Java方法绑定分为前期绑定和后期绑定，除了final和static修饰的方法都是后期绑定。

用继承表达行为间的差异，并用字段表表达状态上的差异

继承更应该是一种纯粹的方式进行，不应该在继承中添加复杂的关系，若有复杂关系应使用组合

抽象类和抽象方法的使用在不同子类可以用不同的方式表达此接口，希望通过抽象类的统一接口操作一系列类。

Interface关键字提供形式，未提供任何具体实现。

抽象类方法必须有body

接口是一种更纯粹的抽象类

如果一个方法操作的是类而不是非接口，那么就只能使用这个类和这个子类，而使用接口可以使方法应用不在此继承结构的某个类，复用性更高。

接口与抽象类的共性：继承和实现抽象类和接口的类能够向上转型为多个基类；防止直接通过创建对象

如果要创建不带任何方法定义和成员变量的基类，那就应该选择接口，如果知道某个事物应该成为一个基类，那么第一选择应该成为一个接口

接口可以多继承

平常使用的service层注入其他service方法就是一种适配器模式表现

接口中的域的写法，增强了域与接口的关联性，是否可以用枚举等的代替；接口中域变量必须初始化

内部类主要作用是把一些逻辑相关的类组织在一起，控制位于内部的类的可见性

内部类拥有创建它的外围对象所有元素访问权，例子：集合中的迭代器

内部类对外部类对象的引用使用外部类名+.this进行应用，创建内部类必须使用外部类对象+.new进行创建

方法里面或任意作用域内定义内部类的目的：实现某类型接口，可以创建并返回对其的引用；需要创建一个类来辅助解决一个问题，但是不希望这个类是公共可用的

匿名内部类也适合只是生成单例的类，比如工厂方法类

嵌套类的作用：要创建嵌套类的对象，并不需要外围类的对象；是内部类对象与外围类对象没有联系

每个内部类都能独立继承自一个接口的实现，无论外围类是否已经继承某个接口实现，对于内部类没有影响，接口解决部分问题，内部类有效的是吸纳了多重继承

内部类可以有多个实例，每个实例都有自己的状态信息，并与外围类对象信息相互独立；在外围类中，可以让多个内部类以不同方式实现同一个接口或继承同一个类；创建内部类时刻不依赖于外围类对象的创建；内部类并没有令人迷惑的is-a关系，就是个独立实体

当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化，每个外围类都有专属自己的内部类，除非明确指定某个内部类。

内部类在编译成class文件时会和外围类区别开，以外围类名+$内部类名.class命名

抛出异常：新建一个异常对象，向调用方法的上一层抛出这个对象以待处理

捕获异常：针对抛出的异常进行指定类型异常的捕获，可向下捕获子类异常，exception是基类异常；什么时候需要捕获异常，当你直到如何处理的情况下才捕获异常

Printstatcktrace打印栈轨迹，getstacktrace获取栈轨迹中元素组成的数组，fillinstacktrace调用栈消息填入原来异常对象，返回最近抛出异常的地方而不是原始抛出异常的地方

Runtimeexception 运行时异常，java程序运行时标准检查异常，比如null，arrayindex异常，通常不需要捕获，表示编程错误

Finally无论try块中异常是否抛出finally块中代码都会得到执行，通常用作关闭资源

当覆盖方法时候，只能抛出在基类方法的异常说明列出的异常；使得基类使用派生类对象时一样能工作；构造方法无视这种异常限制

在创建需要清理的对象后，立即进入一个try-catch语句块

可以将不想，不用做处理的检查异常包含进运行时异常，作为不检查异常

使用+连接string的时候编译器会默认使用stringbuder进行连接，但是还是建议手动编写stringbuider

获取类对象三种方式 1 Class.forName(类全限定名); 2 类.class


instanceOf和isInstance 表示该对象是否属于是该类及该类的父类而obj.getclass == x.class和obj.getclass equals x.class操作表示是否是该类生成对象

RTTI和反射的区别在于，前者在编译器编译时打开和检查.class文件，后者在运行时打开和检查.class文件

动态代理：动态处理所代理方法的调用，在动态代理上所做的调用都会重定向到单一调用处理器上，

普通引用是指没有经过reference对象包装过的引用。

可以使用apt来处理自定义注解

enum可以将一组具有名的值的有限集合创建为一种新的类型，而这些具有名的值可以作为常规的程序组件使用。

enum不可继承，枚举就是一个实例化多个实例的类，每个实例都是唯一

static import 能够将引用的类里面标识带入当前命名空间

所有enum都继承自Enum类，所以enum不能继承其他类

values方法时编译器自动添加的

enum类是是final标记的

可以通过enum嵌套enum的方式得到一个二维的枚举实例（enum实现接口，使用多态性质）

enumSet的基础是long，一个enum实例只需一位bit表示其存在

enumMap是一种特殊的Map，要求其中key来自一个enum，

可为enum编写方法，从而为每个enum实例赋予各自不同的行为。

枚举编写职责链模式（个人觉得不是很适合）

枚举创建状态机

泛型主要的目的：指定容器要持有什么类型的对象

泛型类，泛型方法，泛型接口；使用泛型类的时候必须在创建对象时候指定类型参数的值，使用泛型方法时，通常不必指定参数类型，编译器会自动找出具体类型，称为类型参数推断。

使用泛型容器在对传递进来的值进行编译期检查，对转出去的值进行转型；而不使用泛型的容器在运行时对传进来的值进行检查，对转出去的值进行转型，边界是发生动作的地方

inputstream和outputstream有不同的数据源，1字节数组，string对象，文件，管道，一个由其他类的流组成的序列，internet等其他数据源

jdk1.1大多数用reader和writer代替了input和outputstream的使用

标准i/o,system.in system.out system.err 输出到文件等工具类

新i/o channel buffer 等交互，其他系统输出获取，io映射文件，文件加锁，文件压缩

对象序列化实现了一种轻量级持久性・・・・・・・・・・・・・・・・・・・・

科学计算使用double，float；商业运算使用BigDecimal
