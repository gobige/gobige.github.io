---
layout: post
title: '怎么做一个秒杀系统'
subtitle: '秒杀系统的一些实战经验'
date: 2019-10-12
categories: 性能
author: yates
cover: 'www.baidu.com'
tags: 性能
---

秒杀系统的架构原则

- **数据**要尽量少,**请求**数要尽量少,**路径**要尽量短,**依赖**要尽量少,**不要有单点**.

- “动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和**URL、浏览者、时间、地域相关**，以及**是否含有 Cookie**等私密数据.

- 静态数据做缓存 
1. 将**静态数据缓存**到离用户最近的地方.
2. 对**HTTP连接进行缓存**.(web代理服务器根据请求URL,直接取出对应的HTTP响应头和响应体,直接返回,连HTTP协议都不用从下组装)
3. 使用什么来做缓存

- 分离动态内容:**URL唯一化**,分离**浏览者**相关的因素.分离**时间**因素,异步化**地域**因素,去掉**cookie**.
    - 分离的动态内容在什么地方进行组织(ESI/SSI,在web代理服务器做动态内容请求,并将**请求插入到静态页面**中,用户拿到的是完整的页面2CSI,单独发起一个异步js请求,向**服务端获取动态内容**),用什么结构输出(json)

- 动静分离架构方案:实体机单机部署,统一cache层,上CDN

- **热点数据**的发现:静态热点数据,通过商业手段,活动报名或通过大数据计算统计**TOPN商品**;发现动态热点数据,通过收集交易链路各个环节的中间件产品的热点key,建立热点上报和热点服务下发的规范,提前做好热点数据做好保护,

- 处理热点数据:优化热点数据,**缓存热点数据**,临时缓存热点数据,不管是静态数据还是动态数据,都用一个队列短暂地缓存数秒钟,采用**LRU算法**;数据限制,例如对被访问商品ID做一致性hash,然后对hash做分桶,每个分桶设置一个处理队列,把热点数据限制到一个请求队列,防止热点数据占用太多的服务器资源;对热点数据进行隔离,(业务隔离,做成营销活动,提前**预知热点**;系统隔离,隔离运行时环境;数据隔离,启用单独的cache集群或sql数据库存放热点数据)

- **流量削峰.排队**:
1. 利用线程池**排队**,
2. **先进先出**等常用内存排队算法.
3. 请求**序列化**到文件,再顺序读取文件恢复请求(mysql binlog)
4. 答题:
    - 有效的控制了部分秒杀器在参加秒杀时**作弊**.
    - 有效的**延缓了请求**,起到对请求流量进行削峰的作用,让系统更好的支持瞬时流量高峰.
    - **拉长请求**,靠后的请求后面就无法进行处理,有限了并发写,类似于咻一咻和摇一摇

- **分层过滤**:在不同的层次尽可能**过滤无效请求**,让漏斗最末端才是有效请求
	* 将动态请求**读数据缓存在web端**,过滤**无效数据读**
	* 对**读数据不做强一致性校验**,减少因为一致性校验产生瓶颈问题
	* 对**写数据**进行基于**时间**的合理**分片**,**过滤过期**的失效请求
	* 对写请求做**限流**保护,将超出系统承载能力的请求过滤掉
	* 对**写数据**进行**强一致性**校验,只保留有效的数据
	
- 影响性能的因素,qps,rt,
- 优化系统的方案,减少**编码**,减少**序列化**,java极致优化(直接**用servlet**,直接输出流数据,并发读优化)


- 减库存设计
	- **下单减库存**:会造成竞争对手**恶意下单**的问题
	- **付款减库存**:会造成买家下单成功,付款时由于并发问题,库存不足,**体验不好**
	- **预扣库存**:还是会造成竞争对手恶意下单的情况
	- 辅助:给经常下单不付款的买家进行**识别打标**,设置某些类目**最大购买件数**,**重复下单**不付款的操作进行**次数限制**.对普通商品库存**超卖**情况,进行**补货**方式解决;无法解决的只有提示库存不足.
	
保证库存不为负数
- 通过**事务**判断保证 
- 设置**数据库字段**为无符号整数
- **sql语句**使用case when方式(UPDATE item SET inventory = CASE WHEN inventory >= xxx THEN inventory-xxx ELSE inventory END)

库存的**读取不需要精确性**,可以使用localCache来存储库存数量,**保证读取的效率**,如果秒杀商品减库存逻辑单一,可以在redis之类的缓存中实现;热点商品放到单独的热点库中;解决并发锁有在应用层做排队和在数据库层做排队两种方法

**系统高可用建设**

- 架构阶段:**多机房单元化**部署,提高系统的可扩展和容错性
- 编码阶段:对**错误异常进行捕获**,对无法预料的错误有**默认处理结果**,保证代码的健壮性
- 测试阶段:**测试用例**的完善,覆盖率
- 发布阶段:应该有**回滚机制**
- 运行阶段:有一套成熟的**监控机制**
- 故障发生:故障发生时,**及时止损**,比如商品的及时下架或关闭购买链接,然后才是后续的**服务恢复**

异步请求如何返回
- 采用**轮询**的方式,主动去服务端查询结果,缺点是服务端请求数会增加不少
- **主动push**方式,要求服务端和客户端**保持连接**,缺点服务端连接数比较多