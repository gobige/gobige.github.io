---
layout: post
title: '常见I/O模型'
subtitle: '常见I/O模型'
date: 2017-11-07
categories: 计算机网络
author: yates
cover: 'http://cctv.com'
tags: 计算机网络
---

### 什么是I/O
我们都知道，数据的持久化是发生磁盘的，而能够和硬件打交道的是内核，应用程序想要获得数据就只能通过系统调用获取数据，当进程发生系统调用时，系统进入内核模式，然后开始I/O操作，主要分为两个步骤，1.磁盘把数据装载到内核内存空间 2.内核内存空间拷贝到用户内存空间（I/O发生）

![此处输入图片的描述](http://pev96mxgw.bkt.clouddn.com/img/2018-04-22-computer-system-IO/1.png)

**I/O阻塞**
进程发起I/O调用，内核拷贝数据期间进程会因为等待数据拷贝会挂起，把cpu时间片让出去，此时叫做I/O阻塞，I/O完成，进程会被唤醒。

![此处输入图片的描述](http://pev96mxgw.bkt.clouddn.com/img/2018-04-22-computer-system-IO/2.png)

**非阻塞I/O**
进程发起I/O调用，I/O自己知道需要一段时间才能完成，马上通知进程进行其他操作，叫做非阻塞I/O，在等待期间进程隔一段时间询问是否I/O完成。

![此处输入图片的描述](http://pev96mxgw.bkt.clouddn.com/img/2018-04-22-computer-system-IO/3.png)

**I/O复用**
同时发生多个系统调用，统一使用一个select进行发起调用，内核内存获取到数据后通知调用方，select发起第二阶段的拷贝，进程只会阻塞在第二阶段。

![此处输入图片的描述](http://pev96mxgw.bkt.clouddn.com/img/2018-04-22-computer-system-IO/4.png)


**事件（信号）驱动I/O**
水平触发驱动：内核通知进程读取数据，如果没有读取，不断通知进程
边缘触发驱动：内核只通知一次进程读取数据，进程在超时前可以读取数据

![此处输入图片的描述](http://pev96mxgw.bkt.clouddn.com/img/2018-04-22-computer-system-IO/5.png)


**异步I/O**
进程发起数据请求，内核马上返回信息，进程继续其他操作，内核通知取数据信号，进程处理数据

![此处输入图片的描述](http://pev96mxgw.bkt.clouddn.com/img/2018-04-22-computer-system-IO/6.png)


常见web工作模式
**prefork模式**：
当请求到达时，主进程生成多个工作进程，由工作进程一对一响应请求

**work工作模式**：
当请求到达时，主进程生成多个线程，每个线程去响应客户端请求

**Event工作模式**
当请求到达时，主进程生成多个工作进程，每个进程响应多个客户端请求，当执行I/O操作时，会响应其他请求，等内核通知完成I/O时，重新恢复继续请求处理


**linux中的select poll epoll机制**
select poll epoll都是I/O多路复用机制，我们都知道在linux系统中所有I/O设备都被看作文件，文件通过一个描述符来进行身份识别。I/O多路复用机制其通过监视多个描述符，一旦描述符就绪，就通知程序进行读写响应，属于同步，阻塞的。

##select
**缺点**：

- 单个进程能**监视**的文件描述符**有上限**，通常1024；而且select通过**轮询**方式扫描文件描述符，描述符越多，性能越差
- 在内核和用户空间拷贝数据的时候，select需要复制大量的**引用数据结构**，产生巨大开销。
- select返回的是含有整个引用的数组，应用程序需要遍历整个数组才能发现哪些引用发生了事件
- select触发方式是**水平触发**，

平均的算，1个进程支持1000并发，百万级并发需要1k的进程，加上数据的内核/用户间拷贝，轮询，很难支持万级以上的级别的并发访问

借鉴一张网上的关于**select基本原理**的热图

![此处输入图片的描述](http://pev96mxgw.bkt.clouddn.com/img/2017-11-05-network/3.png) 

**poll**
poll使用链表结构保存文件描述符，没有上限的限制,本质上 和select没多大差别，轮询，内核/用户copy开销，随文件描述符增加开销线性增加

**epoll**
epoll支持同时支持水平和边缘触发，边缘触发效率更高，避免了重复事件触发的次数

epoll通过在linux内核中申请一个简易的文件系统，linux通过以下三个过程实现：

- 调用epoll_create建立一个epoll对象，epll对象有一个独立的eventpoll结构体（红黑树）
- 调用eoll_ctl向epoll对象的eventpoll结构体中添加事件（并且一次性添加描述符），事件都会与设备驱动程序建立回调关系，当相应的事件发生时会回调，将发生的事件添加到rdlist双链表中
- 调用epoll_wait收集发生的事件连接，检查上述添加的rdlist双链表是否为空，将发生的事件复制到用户态
