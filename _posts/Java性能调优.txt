**性能指标**
- 系统负载：代表单位时间内正在运行或等待的进程和线程数。
- 计算机资源分配使用率：
    - CPU占用率：代表单位时间内线程或进程实时占用CPU的百分比
    - I/O：
    - 内存使用率：
- 响应时间：一个请求的响应时间，分为数据库，服务端，网络，客户端响应时间
- 吞吐量：每秒事务处理量（TPS） 
    - 磁盘吞吐量：
        - IOPS：每秒输入输出量（读写次数），单位时间系统处理I/O请求数量。
        - 数据吞吐量：单位时间成功传输数据量。
    - 网络吞吐量：指网络传输时没有帧丢失情况下，设备能够接受最大数据速率。

**测试方法**    
- 微基准性能测试：可以精准定位到某个模块或某个方法性能问题，适用于功能模块或一个方法不同实现方式性能对比。
- 宏准性能测试：模拟线上**正式环境**，并且确定某个测试接口是否有**其它业务接口平行运行**，造成干扰。通过**吞吐量，响应时间**等观察各项指标，衡量系统是否达标。

**需要考虑的问题**

- 热身问题：热身时间过长会导致第一次访问速度过慢，可以考虑先优化，再测试
- 测试结果不稳定：通过多次测试，取平均值
- 多JVM影响：如果多个java应用部署多台tomcat，就会有多个JVM，每一个JVM都拥有整个系统资源使用权。

通过测试结果，观察性能指标，首先从操作系统，查看系统是否异常，再通过日志查找异常日志，分析日志，找到原因。也可通过JVM内存分配和垃圾回收情况查看是否异常。

**调优策略**

- 优化代码
- 优化设计
- 优化算法
- 时间换空间
- 空间换时间
- 参数调优

**兜底策略**

- 限流
- 智能化横向扩容
- 提前扩容

## String字符串优化
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/performance/1.png)

java6版本使用offset和count，可高效共享数组，节省内存，但可能导致内存泄漏
java7/8版本去除offset和count，同时**substring**方法不在共享char[]，避免了内存泄漏
java9char字段改为byte字段，通过coder识别该字符串是否只有单字节编码内字符

**string为什么final修辞**
不仅string类被final修辞，变量char数组也被final修辞，好处:1.保证String对象**安全性**。2保证hash属性值不会频繁变更，**唯一**，类似HashMap能够实现key-value缓存3实现**字符串常量池**

大字符串拼接时，jvm编译器会**默认使用stringbuder**进行拼接节省内存。
字符串常量中，默认会将对象放入常量池；而字符串变量，对象在堆内存中，同时常量池也会创建字符串对象，引用赋值到堆内存对象；
![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/performance/2.png)
字符串分割方法split使用正则表达式，而正则表达式性能非常不稳定，最好使用**string.indexOf**方法代替

正则表达式由正则符号写出的公式，程序对公式进行语法分析，建立语法分析树，再根据分析树结合**正则表达式引擎**生成执行程序（状态机），用于字符匹配。目前引擎有两种：**DFA自动机和NFA自动机**。前者**效率**高于后者，后者支持**更多功能**。NFA实现比较复杂正则表达式，带来的是匹配过程可能会引起大量**回溯**。长时间占用CPU。回溯由于正则表达式使用**贪婪模式**造成的

- 贪婪模式：在数量匹配中，若单独使用+，？，*或{min,max}等量词，正则表达式匹配尽可能多内容
- 懒惰模式：尽可能少重复匹配字符，使用？开启
- 独占模式：和贪婪模式一样最大限度匹配内容，但匹配失败会结束匹配，不会回溯，使用+开启

1少用贪婪，多用独占 2减少分支选择，3减少捕获嵌套

常量池的实现是类似于一个HashTable的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加

程序代码通过链接得到可执行文件，当不同程序链接相同的功能代码的时候时，如果每个都再装载一遍，就会再占用一遍内存。

## **静态链接**
合并代码段就是静态链接

## **动态链接**
链接过程中，我们链接的不是硬盘的目标文件代码，而是加载到内存中的共享库。他会被多个程序指令调用到，Windows下，是dll文件，
linux下，是so文件。
共享代码的基础，这些机器码必须是**地址无关**（无论加载到内存任何地方，都能正常秩序）的。（重定位表的代码，是地址相关的。）虽然共享库用的同一段物理地址，但不同程序，虚拟内存是不同的。

**怎么地址无关**
因为**共享库**放在一段**连续虚拟地址**中，无论装载到哪一段地址，不同指令相对地址都是不变。所以**动态代码内部的变量和函数**调用使用**相对地址**就能解决

**PLT**
在编译过程中，我们指定一个-fPIC参数。用来指定这是一个地址无关的代码

在动态链接对应的共享库，每个应用在data section里，保存了一张**全局偏移表（GOT）**。**虽然共享库物理内存时共享的，但是数据部分各个动态链接它的应用程序里各加载一份**，需要引用共享库外部地址指令时，查询GOT（加载共享库时写入），找到当前应用程序虚拟内存对应共享库位置。

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/computer-system-Perspective/38.png)