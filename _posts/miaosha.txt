秒杀系统的架构原则

- 数据要尽量少,请求数要尽量少,路径要尽量短,依赖要尽量少,不要有单点.

- 动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和 URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据.

- 静态数据做缓存. 将静态数据缓存到离用户最近的地方.2对HTTP连接进行缓存.(web代理服务器根据请求URL,直接取出对应的HTTP响应头和响应体,直接返回,连HTTP协议都不用从下组装)3使用什么来做缓存

- 分离动态内容:URL唯一化,分利浏览者相关的因素.分离时间因素,异步化地域因素,去掉cookie.分离的动态内容在什么地方进行组织(ESI/SSI,在web代理服务器做动态内容请求,并将请求插入到静态页面中,用户拿到的是完整的页面 2CSI,单独发起一个异步js请求,向服务端获取动态内容),用什么结构输出(json)

- 动静分离架构方案:实体机单机部署,统一cache层,上CDN

- 热点数据的发现:静态热点数据,通过商业手段,活动报名或通过大数据计算统计TOP N 商品;发现动态热点数据,通过收集交易链路各个环节的中间件产品的热点key,建立热点上报和热点服务下发的规范,提前做好热点数据做好保护,

- 处理热点数据:优化热点数据,缓存热点数据,临时缓存热点数据,不管是静态数据还是动态数据,都用一个队列短暂地缓存数秒钟,采用LRU算法;数据限制,例如对被访问商品ID做一致性hash,然后对hash做分桶,每个分桶设置一个处理队列,把热点数据限制到一个请求队列,防止热点数据占用太多的服务器资源;对热点数据进行隔离,(业务隔离,做成营销活动,提前预知热点;系统隔离,隔离运行时环境;数据隔离,启用单独的cache集群或sql数据库存放热点数据)

- 流量削峰.排队:利用线程池排队,2先进先出等常用内存排队算法.3请求序列化到文件,再顺序读取文件恢复请求(mysql binlog)
- 答题:1有效的控制了部分秒杀器在参加秒杀时作弊.2有效的延缓了请求,起到对请求流量进行削峰的作用,让系统更好的支持瞬时流量高峰.拉长请求,靠后的请求后面就无法进行处理,有限了并发写,类似于咻一咻和摇一摇

- 分层过滤:在不同的层次尽可能过滤无效请求,让漏斗最末端才是有效请求
	* 将动态请求读数据缓存在web端,过滤无效数据读
	* 对读数据不做强一致性校验,减少因为一致性校验产生瓶颈问题
	* 对写数据进行基于时间的合理分片,过滤掉过期的失效请求
	* 对写请求做限流保护,将超出系统承载能力的请求过滤掉
	* 对写数据进行强一致性校验,只保留有效的数据
	
- 影响性能的因素,qps,rt,
- 优化系统的方案,减少编码,减少序列化,java极致优化(直接用servlet,直接输出流数据,并发读优化)


- 减库存设计
	- 下单减库存:会造成竞争对手恶意下单的问题
	- 付款减库存:会造成买家下单成功,付款时由于并发问题,库存不足,体验不好
	- 预扣库存:还是会造成竞争对手恶意下单的情况
	- 辅助:给经常下单不付款的买家进行识别打标,设置某些类目最大购买件数,重复下单不付款的操作进行次数限制.对普通商品库存超卖情况,进行补货方式解决;无法解决的只有提示库存不足.
	
针对业务场景,秒杀商品在下单扣库存比较合理.
- 保证库存不为负数:1通过事务判断保证 2设置数据库字段为无符号整数3sql语句使用case when方式(UPDATE item SET inventory = CASE WHEN inventory >= xxx THEN inventory-xxx ELSE inventory END)

库存的读取不需要精确性,可以使用localCache来存储库存数量,保证读取的效率,如果秒杀商品减库存逻辑单一,可以在redis之类的缓存中实现;热点商品放到单独的热点库中;解决并发锁有在应用层做排队和在数据库层做排队两种方法

**系统高可用建设**

- 架构阶段:多机房单元化部署,提高系统的可扩展和容错性
- 编码阶段:对错误异常进行捕获,对无法预料的错误有默认处理结果,保证代码的健壮性
- 测试阶段:测试用例的完善,覆盖率
- 发布阶段:应该有回滚机制
- 运行阶段:有一套成熟的监控机制
- 故障发生:故障发生时,及时止损,比如商品的及时下架或关闭购买链接,然后才是后续的服务恢复

异步请求如何返回
- 采用轮询的方式,主动去服务端查询结果,缺点是服务端请求数会增加不少
- 主动push方式,要求服务端和客户端保持连接,缺点服务端连接数比较多