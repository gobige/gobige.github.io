---
layout: post
title: 'Linux性能优化'
subtitle: 'Linux性能优化'
date: 2020-04-03
categories: Linux
author: yates
cover: 'www.baidu.com'
tags: Linux
---


https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/2.png

https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/3.png

## 性能分析常用步骤

- 选择指标评估应用程序和系统性能
- 为应用程序和系统设置性能目标
- 进行性能基准测试
- 性能分析定位瓶颈
- 优化系统和应用程序
- 性能监控和告警

# 平均负载


单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，**平均活跃进程数**

- 可运行状态进程：正在使用或等待CPU的进程
- 不可中断状态进程：正处于内核态关键流程中的进程，且不可中断，例：等待硬件设备I/O响应

当平均负载高于 CPU 数量70%的时候，你就应该分析排查负载高的问题了


**相关指令**

uptime：当前时间；系统运行时间；正登陆用户；CPU平均负载
ps：查看进程运行状态 R-可运行状态进程；D-不可中断状态进程
grep 'model name' /proc/cpuinfo | wc -l：查看cpu核心数

**相关工具**

- stress：（stress --cpu 1 --timeout 600）linux系统压力测试工具模拟异常进程
- sysstat：常用的 Linux 性能工具
	- pidstat：（pidstat -u 5 1 间隔 5S输出 cpu1的数据）常用进程性能分析工具，实时查看进程CPU,内存，I/O，上下文切换指标
	- mpstat：（mpstat -P ALL 5 监控所哟CPU，每5S输出一组数据）多核cpu性能分析工具，用于查看每个CPU性能指标

```java
stress --cpu 1 --timeout 600 // 构造 一个 CPU 密集型进程

stress -i 1 --timeout 600 // 构造一个 I/O 密集型进程

stress -c 8 --timeout 600  构造一个 大量进程的场景
```

## CPU上下文切换

前一个任务的**CPU上下文（CPU寄存器和程序计数器）**，保存到**系统内核**中。加载新任务上下文，跳到程序计数器新位置。

https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/2017-11-12-linux-relation/4.png

内核空间（Ring 0）具有最高权限，可直接访问所有资源

用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备

进程既可以在用户，也可以在内核空间运行，分别为**用户态，内核态**。需要通过**系统调用**来完成

一次**系统调用**的过程，一直在**同一个进程**中运行，其实发生了两次**CPU上下文**切换（用户态和内核态的切换），通常称为特权模式切换，而不是上下文切换。


**进程上下文切换**

每次进程上下文切换都需要**几十纳秒**到**数微秒**CPU时间，大量时间耗费寄存器，内核栈以及虚拟内存**资源的保存和恢复**上，还会导致**TLB的刷新**，**高速缓存的刷新**。

进程上下文切换原因：

- 时间片耗尽
- 资源不足
- sleep函数
- 高优先级进程插入

**线程上下文切换**

线程是**调度**的基本单位，进程是**资源**拥有的基本单位。

切换两种情况：线程所属不同进程。线程属于同一进程

**中断上下文切换**

为了快速响应硬件事件，**中断能处理会打断进程正常调度和执行**

**相关指令**

vmstat指令：分析系统内存使用情况，CPU上下文切换和中断次数
pstree | grep stress : 用树形形式显示所哟进程间关系

[linux指令大全](http://muyibeyond.cn/2017/11/12/linux-file.html)

查看具体进程上下文切换情况：pidstat -w 5 // -t 显示线程上下文次数

```java
UID       PID   cswch/s nvcswch/s  Command
0         1      0.20      0.00  systemd
0         8      5.40      0.00  rcu_sched

cswch:每秒自愿上下文切换 常指 进程无法获取所需资源
nvcswch:每秒非自愿上下文切换 常指 时间片等原因
```

**测试工具**

```java
$ sysbench --threads=10 --max-time=300 threads run // 10个进程运行5分钟基准测试，模拟多线程切换问题
```

```java
watch -d cat /proc/interrupts // /proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况

该显示信息中会有：重调度中断（RES）---表示唤醒空闲状态CPU来调度新任务运行，
多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）

```

- 自愿上下文切换变多，说明进程都在等待资源，有可能发生I/O等问题
- 非自愿上下文切换变多，说明进程被强制调度，都在争抢CPU，说明CPU的确成了瓶颈
- 中断次数变多，CPU被中断处理占用，须通过 /proc/interrupts 查看具体原因


## CPU使用率

Linux通过事先定义**节拍率（内核表示为HZ）**，触发时间中断，并使用全局变量Jiffies记录开机以来节拍数 

```java
grep 'CONFIG_HZ=' /boot/config-$(uname -r) // 查看CPU节拍率

cat /proc/stat | grep ^cpu // 向用户空间提供 CPU相关信息

显示信息 依次 user：用户态 CPU 时间；nice：低优先级用户态 CPU 时间；system：内核态 CPU 时间；
idle：空闲时间；iowait：等待 I/O 的 CPU 时间；irq：处理硬中断的 CPU 时间；softirq：软中断的 CPU 时间；
steal：当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间；guest：运行虚拟机的 CPU 时间；
guest_nice：低优先级运行虚拟机的时间
```

平均CPU使用率 = 1 - (空闲时间new - 空闲时间old)/(总CPU时间new - 总CPU时间old)

Linux 也给每个进程提供了运行情况的统计信息，也就是 /proc/[pid]/stat

**相关指令**

top：显示系统总体CPU和内存使用情况，各个进程资源使用情况 // CPU使用率包含了用户态和内核态，具体细分要用pidstat
ps：显示每个进程资源使用情况


[linux指令大全](http://muyibeyond.cn/2017/11/12/linux-file.html)

perf top：实时显示占用CPU时钟最多函数或指令
perf record：保存数据
perf report：解析数据

```java
$ perf top

// 采样数（Samples）、事件类型（event）和事件总数量（Event count）
Samples: 833  of event 'cpu-clock', Event count (approx.): 97742399 
Overhead  Shared Object       Symbol
   7.28%  perf                [.] 0x00000000001f78a4
   4.72%  [kernel]            [k] vsnprintf
   4.32%  [kernel]            [k] module_get_kallsym
   3.65%  [kernel]            [k] _raw_spin_unlock_irqrestore
...

Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等
Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间
Symbol 是符号名，也就是函数名
```

**相关工具**

execsnoop 就是一个专为**短时进程**设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括**进程 PID、父进程 PID、命令行参数以及执行的结果**

碰到常规问题无法解释的 CPU 使用率情况时，首先要想到有可能是短时应用导致的问题

- 用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。
- 系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。
- I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题。
- 软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序。

## 线程状态

R：表示进程在CPU的就绪队列中，**运行或正在等待运行**
D：**不可中断状态睡眠**，一般表示进程正跟硬件交互  // 若是系统或硬件发生故障，进程可能会在不可中断状态保持很久，导致系统出现大量不可中断进程
Z：僵尸进程（进程结束了，但是父进程没有回收它资源，描述符，PID）// 父进程创建子进程后，通过wait或waitpid等待子进程结束；子进程结束时，会向它父进程发送SIGCHLD信号；父进程可以注册处理函数，异步回收资源；父进程没来得及处理或子进程执行太快都会导致僵尸进程的出现
S：**可中断状态睡眠**，进程**等待某个事件**被系统挂起。
I：空闲状态，不可中断睡眠内核线程上。除了D状态的进程状态
T/t：进程处于暂停或跟踪状态
X：进程已消亡


**相关工具**

dstat：同时观察系统CPU，磁盘I/O，网络以及内存使用情况


**进程组合会话**

- 进程组表示**一组相互关联的进程**，每个子进程都是父进程所在组成员
- 会话指共享同一个控制终端的**一个或多个进程组**

iowait 高不一定代表I/O 有性能瓶颈。当系统中**只有 I/O 类型的进程在运行**时，**iowait也会很高**，但实际上，磁盘的读写远没有达到性能瓶颈的程度。
 
## 中断

- **中断**其实是一种**异步**的事件处理机制，可以**提高系统的并发**处理能力；为了减少对正常进程运行影响，中断处理需尽可能快运行
- 中断处理程序在响应中断时，会临时关闭中断

**软中断**

为了解决中断处理程序执行过长和中断丢失，中断处理过程分成两个阶段

- 上半部分**快速处理中断**，**硬中断**
- 下半部分用来延迟上半部分未完成工作，通常以**内核线程**方式运行，**软中断**。一些内核自定义事件也属于软中断

```java
/proc/softirqs 提供了软中断的运行情况；
/proc/interrupts 提供了硬中断的运行情况。
```

Linux 中，**每个CPU**都对应一个**软中断内核线程**，名字是ksoftirqd/CPU编号.**软中断**事件的**频率过高**时，内核线程也会因为CPU使用率过高而导致**软中断处理不及时**，进而引发**网络收发延迟、调度缓慢**等性能问题。


**相关工具**

- sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据
- hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等
- tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。

