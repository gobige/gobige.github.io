---
layout: post
title: '正则表达式'
subtitle: '威力无比的正则表达式'
date: 2020-09-26
categories: 语言
author: yates
cover: 'http://cctv.com'
tags: 语言
---

## 前言

正则表表达式作为一种强大文本处理工具，可以用于执行各种复杂的文本处理和操作，并且在不同平台，不同语言都有支持。那么怎么才能用好它呢

## **为什么要克制使用？**

正则表达式功能强大，处理速度快，但是天书符咒般的写法，从软件工程的角度看来，大大降低了程序的**可读性**和**可维护性**

**能用普通字符串处理的，坚决用普通字符串处理**

字符串**处理速度**不见得比正则差，但**可读性**却好很多

## **使用正则正确姿势**

**每一个正则都需要注释**

你看得懂，你的同事不一定看得懂；你现在看得懂，过一阵子，不一定还能看懂。

**多个简单正则表达式代替一个复杂正则表达式**

通过拆分，分别对多个验证条件进行验证


## **正则能做什么**

- 校验数据有效性：
- 查找符合要求文本内容
- 对文本进行切割，替换

### **正则的结构**

- **元字符：**在正则表达式中具有特殊意义的专用字符
    - **特殊单字符：** 
        - "."任意字符
        - "\d"任意数字   "\D"任意非数字
        - "\w"任意字母数字下划线  "\W"任意非字母数字下划线  
        - "\s"任意空白符   "\S"任意非空白符 
    - **空白符：**
        - "\r"回车符
        - "\n"换行符
        - "\f"换页符
        - "\t"制表符
        - "\v"垂直制表符
    - **量词：**
        - "*" 0到多次
        - "+" 1到多次
        - "?" 1或0次
        - {m} 出现m次
        - {m,} 出现至少m次
        - {m,n} 出现m到n次
    - **范围：**
        - "|" 或
        - "[...]" 多选一，括号中任意单个元素
        - "[a-z]" a到z之间任意单个元素·
        - "[^...]" 取反，不是括号中任意单个元素


### **模式**

**贪婪模式**

表示次数的量词，默认是贪婪的，默认**尽可能多的去匹配**，会发生向后回溯（回吐）

**非贪婪模式**

"数量"元字符后面加**?**，找出**长度最小**且满足要求的，会发生向前回溯

**独占模式**

**尽可能多去匹配**，匹配**失败就结束**，不会回溯；

独占模式，但是某些**场景**会不满足需求；而且不同**语言支持度**也不一样	

### **分组与引用**

正则在处理**多分支匹配**时，都是**左边的优先匹配**

**括号**在正则中可以用于**分组**，表示一个子表达式的子组。

通过将某部分看成一个整体，在后续查找和**替换**中引用分组

- **分组编号：**
    - 第几个括号就是第几个分组，
    - ?: 不保存子组，不会生成编号；
    - 括号嵌套只需要看左括号的序号是多少就表示第几个分组
    - 命名分组 ?P<名称> 正则，便于通过命名对分组进行引用（不同语言支持度不一样）
- **分组引用**
	- 通过\number 或 $number 进行引用（不同语言方式不同）
    - 查找**重复**出现的部分
    - 对原有内容格式进行**改写，替换**


### **匹配模式**

**不区分大小写模式(?i)**

修饰符在括号内还是括号外具有不同的意义

**点号通配模式(?s)**

把文本当成**单行**进行匹配，也叫作 单行匹配，可以匹配任意字符，包括换行

**多行模式(?m)**

进行**多行匹配**，通过^和&匹配上**每行**的开头和末尾

**注释模式(?#comment)**

使正则更容易阅读



## 正则断言
 
在我们进行正则匹配的过程中，有些情况下，我们需要对匹配的**文本的位置**有一定的要求。 正则提供断言的方式用于匹配位置。

### **单词边界**

**\b**：理解为边界（Boundary），正则中可以表示为单词的边界

### **行的开始/结束**

使用^和$进行位置界定每行的开始和结束，匹配要求的内容以行首或行尾出现。比如**日志起始行判断，输入数据校验**

### **环视**

环视要求匹配**部分**前面或后面要满足某种规则，**零宽断言**

```java
 ?<=Y：肯定逆序环视，左边是Y
 ?<!Y：否定逆序环视，左边不是Y
 ?=Y：肯定顺序环视，右边是Y
 ?!=Y：否定顺序环视，右边不是Y
```

**子组的作用是匹配文本内容，后续用于替换等操作；环视是对文本左右环境的要求，只匹配位置，不匹配文本内容**

## 转义字符

字符序列中的转义字符对其后续几个字符进行**替代并解释**

### **通常用法**

- 编码无法用字母表直接表示的特殊数据
- 无法直接键盘录入的字符（回车符）


### **常见转义字符**

- \n 换行
- \r 回车
- \t 水平制表
- \v 垂直制表
- \\\\ 反斜线字符
- \\' 单引号字符
- \\" 双引号字符

### **正则转义**

正则中使用**反斜杠**进行转义

**如果要在文本中查找转义的反斜杠，则需要4个\\**

**正则中方括号[]和花括号{}只需转义开括号，但圆括号()两个都要转义**

### **转义函数**

不同编程语言自带转义函数进行转义

```java
Python:re.escape(text)
Go:regexp.QuoteMeta(text)
Java:Pattern.quote(text)
PHP:preg_quote(text)
```

### **字符组转义的情况**

**脱字符在中括号中，且在第一个位置**

```java
[^ab]  表示非

[\^ab] 表示独立字符^
```

**中划线在中括号中，且不在首尾位置**

```java
[a-c] 表示a到c中任意字符
[a\-c] 表示独立字符 a，\，c
```

**右括号在中括号中，且不在首位**

```java
[a]b] 匹配ab]
[a\]b] 匹配 a，]，b
```

字符组中其他**元字符(.*+?())**在中括号中不需要转义即可表达单个字符本身的含义。

```java
[.*+?()]  表示独立字符 .，*，+，?，(，)
```

## 正则表达式的流派

- POSIX标准：Unix系统或累Unix系统大部分工具遵循的标准.分为基本正则表达式**BRE**和扩张正则表达式**ERE**

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/regex/1.jpg)

POSIX字符组

![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/regex/2.png)

- PCRE标准：基于Perl语言第一版引入正则而得到的解析标准

PCRE流派中直接兼容的有Perl，PHP，preg等语言库；间接兼容的有Java系，Python，JS，.NET等语言


![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/regex/3.png)

有些不同的工具同时兼容两种标准，例如：

```java
grep -E 使用ERE标准

grep -P 使用PCRE标准
```

**我们常用的语言中字符串正则处理，查找匹配，提取内容，替换，分割等操作，Java由于没有原生字符串所以在使用转义字符\时需要对其转义\\**

## 字符编码的正则匹配

Unicode对世界上大部分文字进行整理，编码。使得计算机呈现，处理文字变得简单。

现Unicode字符分为**17组编排**，每组一个平面，**每个平面65536个码值**。

在正则匹配过程中，如果不使用Unicode，正则会被编译成其他编码表示形式，每个**编码形式最终使得正则匹配可能通过单字符进行匹配**，导致匹配异常

**点号在不同语言中对Nnicode字符匹配的支持不一样，同样字符组也是**

Unicode的属性可以把Unicode字符集划分成不同的字符小集合


![](https://yatesblog.oss-cn-shenzhen.aliyuncs.com/img/regex/4.png)


## 正则匹配原理

### **有穷状态自动机**

一个系统具有有穷个状态，不同状态代表不同意义；系统根据相应条件，不同状态下进行转移。

- DFA：**确定性有穷自动机**，先查看匹配字符串，再检查正则表达式。匹配字符串只会被查看一次，不会发生回溯
- NFA：**非确定性有穷自动机**，先检查正则表达式，在查看匹配字符串。


### **回溯**
只有在NFA引擎才有，且正则中出现**量词，多选分支结构**时，才会发生回溯

在**贪婪模式**下，可能会导致大量回溯，造成**匹配内容不断吐出，再次尝试**的过程

**POSIX NFA**相比传统NFA会在找到可能**最长匹配**之前会继续回溯，找到最长匹配

### **正则优化**

**测试性能**

通过**耗时和文本匹配次数（regex101.com）**来得知正则性能信息

- **提前编译正则**
- **尽量准确表示匹配范围**：".+?"和[^"]+进行引号里面内容进行匹配，前者会将引号匹配上，再吐出
- **提取公共部分**：例如(abcd|abxy)替换为ab(cd|xy)减少字符串匹配中某些部分重复匹配多次
- **出现可能性大的放左边**：(net|com) 替换为(com|net)
- **只有必要时才使用子组**：括号可用于归组，在后续部分不再用到，就不需要保存成子组。使用?:表示只用于归组。避免正则引擎的额外保存匹配内容的工作
- **警惕嵌套的子组重复**：一个组内容重复，这个组整体也可以重复，匹配次数会指数级增长
- **避免不同分支重复匹配**：回溯带来的匹配问题

## 正则处理思路 

- 大问题拆分为小问题
- 多个字符使用字符组
- 相同位置多字符串选择，使用多选结构
- 出现次数不确定使用量词
- 位置出现有要求使用锚点锁定位置
